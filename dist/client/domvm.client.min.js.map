{"version":3,"file":"domvm.client.min.js","sources":["../../src/utils.js","../../src/view/VNode.js","../../src/view/defineText.js","../../src/view/utils.js","../../src/view/addons/autoPx.js","../../src/view/addons/cssTag.js","../../src/view/addons/streamCfg.js","../../src/view/initElementNode.js","../../src/view/preProc.js","../../src/view/patchStyle.js","../../src/view/hooks.js","../../src/view/dom.js","../../src/view/config.js","../../src/view/patchEvent.js","../../src/view/patchAttrs.js","../../src/view/createView.js","../../src/view/hydrate.js","../../src/view/syncChildren.js","../../src/view/addons/lazyList.js","../../src/view/patch.js","../../src/view/ViewModel.js","../../src/view/defineElement.js","../../src/view/defineSvgElement.js","../../src/view/defineComment.js","../../src/view/VView.js","../../src/view/defineView.js","../../src/view/VModel.js","../../src/view/injectView.js","../../src/view/injectElement.js","../../src/view/addons/patch.js","../../src/view/addons/emit.js","../../src/view/addons/vmBody.js","../../src/view/addons/attach.js","../../src/view/VTYPES.js","../../src/builds/pico.js","../../src/view/addons/diff.js","../../src/view/addons/streamFlyd.js","../../src/builds/mini.js"],"sourcesContent":["export const ENV_DOM = typeof window !== \"undefined\";\nexport const TRUE = true;\nconst win = ENV_DOM ? window : {};\nconst rAF = win.requestAnimationFrame;\n\nexport const emptyObj = {};\n\nexport function noop() {};\n\nexport const isArr = Array.isArray;\n\nexport function isSet(val) {\n\treturn val != null;\n}\n\nexport function isPlainObj(val) {\n\treturn val != null && val.constructor === Object;\t\t//  && typeof val === \"object\"\n}\n\nexport function insertArr(targ, arr, pos, rem) {\n\ttarg.splice.apply(targ, [pos, rem].concat(arr));\n}\n\nexport function isVal(val) {\n\tvar t = typeof val;\n\treturn t === \"string\" || t === \"number\";\n}\n\nexport function isFunc(val) {\n\treturn typeof val === \"function\";\n}\n\nexport function isProm(val) {\n\treturn typeof val === \"object\" && isFunc(val.then);\n}\n\nexport function isElem(val) {\n\treturn ENV_DOM && val instanceof HTMLElement;\n}\n\nexport function assignObj(targ) {\n\tvar args = arguments;\n\n\tfor (var i = 1; i < args.length; i++)\n\t\tfor (var k in args[i])\n\t\t\ttarg[k] = args[i][k];\n\n\treturn targ;\n}\n\n// export const defProp = Object.defineProperty;\n\nexport function deepSet(targ, path, val) {\n\tvar seg;\n\n\twhile (seg = path.shift()) {\n\t\tif (path.length === 0)\n\t\t\ttarg[seg] = val;\n\t\telse\n\t\t\ttarg[seg] = targ = targ[seg] || {};\n\t}\n}\n\n/*\nexport function deepUnset(targ, path) {\n\tvar seg;\n\n\twhile (seg = path.shift()) {\n\t\tif (path.length === 0)\n\t\t\ttarg[seg] = val;\n\t\telse\n\t\t\ttarg[seg] = targ = targ[seg] || {};\n\t}\n}\n*/\n\nexport function sliceArgs(args, offs) {\n\tvar arr = [];\n\tfor (var i = offs; i < args.length; i++)\n\t\tarr.push(args[i]);\n\treturn arr;\n}\n\nexport function cmpObj(a, b) {\n\tfor (var i in a)\n\t\tif (a[i] !== b[i])\n\t\t\treturn false;\n\n\treturn true;\n}\n\nexport function cmpArr(a, b) {\n\tconst alen = a.length;\n\n\tif (b.length !== alen)\n\t\treturn false;\n\n\tfor (var i = 0; i < alen; i++)\n\t\tif (a[i] !== b[i])\n\t\t\treturn false;\n\n\treturn true;\n}\n\n// https://github.com/darsain/raft\n// rAF throttler, aggregates multiple repeated redraw calls within single animframe\nexport function raft(fn) {\n\tif (!rAF)\n\t\treturn fn;\n\n\tvar id, ctx, args;\n\n\tfunction call() {\n\t\tid = 0;\n\t\tfn.apply(ctx, args);\n\t}\n\n\treturn function() {\n\t\tctx = this;\n\t\targs = arguments;\n\t\tif (!id) id = rAF(call);\n\t};\n}\n\nexport function curry(fn, args, ctx) {\n\treturn function() {\n\t\treturn fn.apply(ctx, args);\n\t};\n}\n\nexport function prop(val, cb, ctx, args) {\n\treturn function(newVal, execCb) {\n\t\tif (newVal !== undefined && newVal !== val) {\n\t\t\tval = newVal;\n\t\t\texecCb !== false && isFunc(cb) && cb.apply(ctx, args);\n\t\t}\n\n\t\treturn val;\n\t};\n}\n\n// adapted from https://github.com/Olical/binary-search\nexport function binaryKeySearch(list, item) {\n    var min = 0;\n    var max = list.length - 1;\n    var guess;\n\n\tvar bitwise = (max <= 2147483647) ? true : false;\n\tif (bitwise) {\n\t\twhile (min <= max) {\n\t\t\tguess = (min + max) >> 1;\n\t\t\tif (list[guess].key === item) { return guess; }\n\t\t\telse {\n\t\t\t\tif (list[guess].key < item) { min = guess + 1; }\n\t\t\t\telse { max = guess - 1; }\n\t\t\t}\n\t\t}\n\t} else {\n\t\twhile (min <= max) {\n\t\t\tguess = Math.floor((min + max) / 2);\n\t\t\tif (list[guess].key === item) { return guess; }\n\t\t\telse {\n\t\t\t\tif (list[guess].key < item) { min = guess + 1; }\n\t\t\t\telse { max = guess - 1; }\n\t\t\t}\n\t\t}\n\t}\n\n    return -1;\n}","export function VNode() {}\n\nexport const VNodeProto = VNode.prototype = {\n\tconstructor: VNode,\n\n\ttype:\tnull,\n\n\tvm:\t\tnull,\n\n\t// all this stuff can just live in attrs (as defined) just have getters here for it\n\tkey:\tnull,\n\tref:\tnull,\n\tdata:\tnull,\n\thooks:\tnull,\n\traw:\tfalse,\n\tns:\t\tnull,\n\n\tel:\t\tnull,\n\n\ttag:\tnull,\n\tattrs:\tnull,\n\tbody:\tnull,\n\n\tflags:\t0,\n\n\t_class:\tnull,\n\t_diff:\tnull,\n\n\tidx:\tnull,\n\tparent:\tnull,\n\n\t/*\n\t// break out into optional fluent module\n\tkey:\tfunction(val) { this.key\t= val; return this; },\n\tref:\tfunction(val) { this.ref\t= val; return this; },\t\t// deep refs\n\tdata:\tfunction(val) { this.data\t= val; return this; },\n\thooks:\tfunction(val) { this.hooks\t= val; return this; },\t\t// h(\"div\").hooks()\n\thtml:\tfunction(val) { this.html\t= true; return this.body(val); },\n\n\tbody:\tfunction(val) { this.body\t= val; return this; },\n\t*/\n};","import { TEXT } from './VTYPES';\nimport { VNode } from './VNode';\n\nexport function defineText(body) {\n\tlet node = new VNode;\n\tnode.type = TEXT;\n\tnode.body = body;\n\treturn node;\n}","import { emptyObj } from '../utils';\n\nexport function isEvProp(name) {\n\treturn name[0] === \"o\" && name[1] === \"n\";\n}\n\nexport function isSplProp(name) {\n\treturn name[0] === \"_\";\n}\n\nexport function isStyleProp(name) {\n\treturn name === \"style\";\n}\n\nexport function repaint(node) {\n\tnode && node.el && node.el.offsetHeight;\n}\n\n// tests interactive props where real val should be compared\nexport function isDynProp(tag, attr) {\n//\tswitch (tag) {\n//\t\tcase \"input\":\n//\t\tcase \"textarea\":\n//\t\tcase \"select\":\n//\t\tcase \"option\":\n\t\t\tswitch (attr) {\n\t\t\t\tcase \"value\":\n\t\t\t\tcase \"checked\":\n\t\t\t\tcase \"selected\":\n//\t\t\t\tcase \"selectedIndex\":\n\t\t\t\t\treturn true;\n\t\t\t}\n//\t}\n\n\treturn false;\n}\n\nexport function getVm(n) {\n\tn = n || emptyObj;\n\twhile (n.vm == null && n.parent)\n\t\tn = n.parent;\n\treturn n.vm;\n}","import { TRUE } from '../../utils';\n\nconst unitlessProps = {\n\tanimationIterationCount: TRUE,\n\tboxFlex: TRUE,\n\tboxFlexGroup: TRUE,\n\tcolumnCount: TRUE,\n\tcounterIncrement: TRUE,\n//\tfillOpacity: TRUE,\n\tflex: TRUE,\n\tflexGrow: TRUE,\n\tflexOrder: TRUE,\n\tflexPositive: TRUE,\n\tflexShrink: TRUE,\n\tfloat: TRUE,\n\tfontWeight: TRUE,\n\tgridColumn: TRUE,\n\tlineHeight: TRUE,\n\tlineClamp: TRUE,\n\topacity: TRUE,\n\torder: TRUE,\n\torphans: TRUE,\n//\tstopOpacity: TRUE,\n//\tstrokeDashoffset: TRUE,\n//\tstrokeOpacity: TRUE,\n//\tstrokeWidth: TRUE,\n\ttabSize: TRUE,\n\ttransform: TRUE,\n\ttransformOrigin: TRUE,\n\twidows: TRUE,\n\tzIndex: TRUE,\n\tzoom: TRUE,\n};\n\nexport function autoPx(name, val) {\n\t// typeof val === 'number' is faster but fails for numeric strings\n\treturn !isNaN(val) && !unitlessProps[name] ? (val + \"px\") : val;\n}","const tagCache = {};\n\nconst RE_ATTRS = /\\[(\\w+)(?:=(\\w+))?\\]/g;\n\n//\tfunction VTag() {}\nexport function cssTag(raw) {\n\tvar cached = tagCache[raw];\n\n\tif (cached == null) {\n\t\tvar tag, id, cls, attr;\n\n\t\ttagCache[raw] = cached = {\n\t\t\ttag:\t(tag\t= raw.match( /^[-\\w]+/))\t\t?\ttag[0]\t\t\t\t\t\t: \"div\",\n\t\t\tid:\t\t(id\t\t= raw.match( /#([-\\w]+)/))\t\t? \tid[1]\t\t\t\t\t\t: null,\n\t\t\tclass:\t(cls\t= raw.match(/\\.([-\\w.]+)/))\t\t?\tcls[1].replace(/\\./g, \" \")\t: null,\n\t\t\tattrs:\tnull,\n\t\t};\n\n\t\twhile (attr = RE_ATTRS.exec(raw)) {\n\t\t\tif (cached.attrs == null)\n\t\t\t\tcached.attrs = {};\n\t\t\tcached.attrs[attr[1]] = attr[2] || \"\";\n\t\t}\n\t}\n\n\treturn cached;\n}","export let isStream = function() { return false };\n\nlet streamVal = null;\nlet subStream = null;\nlet unsubStream = null;\n\n/* example flyd adapter:\n{\n\tis:\t\ts => flyd.isStream(s),\n\tval:\ts => s(),\n\tsub:\t(s,fn) => flyd.on(fn, s),\n\tunsub:\ts => s.end(),\n}\n*/\nexport function streamCfg(cfg) {\n\tisStream\t= cfg.is;\n\tstreamVal\t= cfg.val;\n\tsubStream\t= cfg.sub;\n\tunsubStream\t= cfg.unsub;\n}\n\n// creates a one-shot self-ending stream that redraws target vm\n// TODO: if it's already registered by any parent vm, then ignore to avoid simultaneous parent & child refresh\nexport function hookStream(s, vm) {\n\tvar redrawStream = subStream(s, val => {\n\t\t// this \"if\" ignores the initial firing during subscription (there's no redrawable vm yet)\n\t\tif (redrawStream) {\n\t\t\t// if vm fully is formed (or mounted vm.node.el?)\n\t\t\tif (vm.node != null)\n\t\t\t\tvm.redraw();\n\t\t\tunsubStream(redrawStream);\n\t\t}\n\t});\n\n\treturn streamVal(s);\n}","import { ELEMENT } from './VTYPES';\nimport { VNode } from './VNode';\nimport { cssTag } from './addons/stubs';\nimport { isSet, isPlainObj } from '../utils';\nimport { devNotify } from \"./addons/devmode\";\n\n// (de)optimization flags\n\n// prevents inserting/removing/reordering of children\nexport const FIXED_BODY = 1;\n// forces slow bottom-up removeChild to fire deep willRemove/willUnmount hooks,\nexport const DEEP_REMOVE = 2;\n// enables fast keyed lookup of children via binary search, expects homogeneous keyed body\nexport const KEYED_LIST = 4;\n// indicates an vnode match/diff/recycler function for body\nexport const LAZY_LIST = 8;\n\nexport function initElementNode(tag, attrs, body, flags) {\n\tlet node = new VNode;\n\n\tnode.type = ELEMENT;\n\n\tif (isSet(flags))\n\t\tnode.flags = flags;\n\n\tnode.attrs = attrs;\n\n\tvar parsed = cssTag(tag);\n\n\tnode.tag = parsed.tag;\n\n\t// meh, weak assertion, will fail for id=0, etc.\n\tif (parsed.id || parsed.class || parsed.attrs) {\n\t\tvar p = node.attrs || {};\n\n\t\tif (parsed.id && !isSet(p.id))\n\t\t\tp.id = parsed.id;\n\n\t\tif (parsed.class) {\n\t\t\tnode._class = parsed.class;\t\t// static class\n\t\t\tp.class = parsed.class + (isSet(p.class) ? (\" \" + p.class) : \"\");\n\t\t}\n\t\tif (parsed.attrs) {\n\t\t\tfor (var key in parsed.attrs)\n\t\t\t\tif (!isSet(p[key]))\n\t\t\t\t\tp[key] = parsed.attrs[key];\n\t\t}\n\n//\t\tif (node.attrs !== p)\n\t\t\tnode.attrs = p;\n\t}\n\n\tvar mergedAttrs = node.attrs;\n\n\tif (isSet(mergedAttrs)) {\n\t\tif (isSet(mergedAttrs._key))\n\t\t\tnode.key = mergedAttrs._key;\n\n\t\tif (isSet(mergedAttrs._ref))\n\t\t\tnode.ref = mergedAttrs._ref;\n\n\t\tif (isSet(mergedAttrs._hooks))\n\t\t\tnode.hooks = mergedAttrs._hooks;\n\n\t\tif (isSet(mergedAttrs._raw))\n\t\t\tnode.raw = mergedAttrs._raw;\n\n\t\tif (isSet(mergedAttrs._data))\n\t\t\tnode.data = mergedAttrs._data;\n\n\t\tif (isSet(mergedAttrs._flags))\n\t\t\tnode.flags = mergedAttrs._flags;\n\n\t\tif (!isSet(node.key)) {\n\t\t\tif (isSet(node.ref))\n\t\t\t\tnode.key = node.ref;\n\t\t\telse if (isSet(mergedAttrs.id))\n\t\t\t\tnode.key = mergedAttrs.id;\n\t\t\telse if (isSet(mergedAttrs.name))\n\t\t\t\tnode.key = mergedAttrs.name;\n\t\t}\n\t}\n\n\tif (body != null)\n\t\tnode.body = body;\n\n\tif (_DEVMODE) {\n\t\tif (node.tag === \"svg\") {\n\t\t\tsetTimeout(function() {\n\t\t\t\tnode.ns == null && devNotify(\"SVG_WRONG_FACTORY\", [node]);\n\t\t\t}, 16);\n\t\t}\n\t\telse if (node.tag === \"input\" && node.key == null)\n\t\t\tdevNotify(\"UNKEYED_INPUT\", [node]);\n\t}\n\n\treturn node;\n}","import { TEXT, VVIEW, VMODEL } from './VTYPES';\nimport { defineText } from './defineText';\nimport { isVal, isArr, isFunc, insertArr, deepSet } from '../utils';\nimport { getVm } from './utils';\nimport { isStream, hookStream } from './addons/stubs';\nimport { DEEP_REMOVE } from './initElementNode';\n\nfunction setRef(vm, name, node) {\n\tvar path = [\"refs\"].concat(name.split(\".\"));\n\tdeepSet(vm, path, node);\n}\n\nfunction setDeepRemove(node) {\n\twhile (node = node.parent)\n\t\tnode.flags |= DEEP_REMOVE;\n}\n\n// vnew, vold\nexport function preProc(vnew, parent, idx, ownVm) {\n\tif (vnew.type === VMODEL || vnew.type === VVIEW)\n\t\treturn;\n\n\tvnew.parent = parent;\n\tvnew.idx = idx;\n\tvnew.vm = ownVm;\n\n\tif (vnew.ref != null)\n\t\tsetRef(getVm(vnew), vnew.ref, vnew);\n\n\tif (vnew.hooks && vnew.hooks.willRemove || ownVm && ownVm.hooks && ownVm.hooks.willUnmount)\n\t\tsetDeepRemove(vnew);\n\n\tif (isArr(vnew.body))\n\t\tpreProcBody(vnew);\n\telse if (isStream(vnew.body))\n\t\tvnew.body = hookStream(vnew.body, getVm(vnew));\n}\n\nexport function preProcBody(vnew) {\n\tvar body = vnew.body;\n\n\tfor (var i = 0; i < body.length; i++) {\n\t\tvar node2 = body[i];\n\n\t\t// remove false/null/undefined\n\t\tif (node2 === false || node2 == null)\n\t\t\tbody.splice(i--, 1);\n\t\t// flatten arrays\n\t\telse if (isArr(node2))\n\t\t\tinsertArr(body, node2, i--, 1);\n\t\telse {\n\t\t\tif (node2.type == null)\n\t\t\t\tbody[i] = node2 = defineText(\"\"+node2);\n\n\t\t\tif (node2.type === TEXT) {\n\t\t\t\t// remove empty text nodes\n\t\t\t\tif (node2.body == null || node2.body === \"\")\n\t\t\t\t\tbody.splice(i--, 1);\n\t\t\t\t// merge with previous text node\n\t\t\t\telse if (i > 0 && body[i-1].type === TEXT) {\n\t\t\t\t\tbody[i-1].body += node2.body;\n\t\t\t\t\tbody.splice(i--, 1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tpreProc(node2, vnew, i, null);\n\t\t\t}\n\t\t\telse\n\t\t\t\tpreProc(node2, vnew, i, null);\n\t\t}\n\t}\n}","import { isVal, emptyObj } from '../utils';\nimport { getVm } from './utils';\nimport { autoPx, isStream, hookStream } from './addons/stubs';\n\n// assumes if styles exist both are objects or both are strings\nexport function patchStyle(n, o) {\n\tvar ns =     (n.attrs || emptyObj).style;\n\tvar os = o ? (o.attrs || emptyObj).style : null;\n\n\t// replace or remove in full\n\tif (ns == null || isVal(ns))\n\t\tn.el.style.cssText = ns;\n\telse {\n\t\tfor (var nn in ns) {\n\t\t\tvar nv = ns[nn];\n\n\t\t\tif (isStream(nv))\n\t\t\t\tnv = hookStream(nv, getVm(n));\n\n\t\t\tif (os == null || nv != null && nv !== os[nn])\n\t\t\t\tn.el.style[nn] = autoPx(nn, nv);\n\t\t}\n\n\t\t// clean old\n\t\tif (os) {\n\t\t\tfor (var on in os) {\n\t\t\t\tif (ns[on] == null)\n\t\t\t\t\tn.el.style[on] = \"\";\n\t\t\t}\n\t\t}\n\t}\n}","import { isArr } from '../utils';\nimport { repaint } from './utils';\n\nexport const didQueue = [];\n\nfunction fireHook(did, fn, o, n, immediate) {\n\tif (did) {\t// did*\n\t\t//\tconsole.log(name + \" should queue till repaint\", o, n);\n\t\timmediate ? repaint(o.parent) && fn(o, n) : didQueue.push([fn, o, n]);\n\t}\n\telse {\t\t// will*\n\t\t//\tconsole.log(name + \" may delay by promise\", o, n);\n\t\treturn fn(o, n);\t\t// or pass  done() resolver\n\t}\n}\n\nexport function fireHooks(name, o, n, immediate) {\n\tvar hook = o.hooks[name];\n\n\tif (hook) {\n\t\tvar did = name[0] === \"d\" && name[1] === \"i\" && name[2] === \"d\";\n\n\t\tif (isArr(hook)) {\n\t\t\t// TODO: promise.all() this?\n\t\t\treturn hook.map(function(hook2) {\n\t\t\t\treturn fireHook(did, hook2, o, n);\n\t\t\t});\n\t\t}\n\t\telse\n\t\t\treturn fireHook(did, hook, o, n, immediate);\n\t}\n}","import { ENV_DOM, isArr, isProm, curry } from '../utils';\nimport { fireHooks } from './hooks';\nimport { FIXED_BODY, DEEP_REMOVE } from './initElementNode';\n\nconst doc = ENV_DOM ? document : null;\n\nexport function closestVNode(el) {\n\twhile (el._node == null)\n\t\tel = el.parentNode;\n\treturn el._node;\n}\n\nexport function createElement(tag, ns) {\n\tif (ns != null)\n\t\treturn doc.createElementNS(ns, tag);\n\treturn doc.createElement(tag);\n}\n\nexport function createTextNode(body) {\n\treturn doc.createTextNode(body);\n}\n\nexport function createComment(body) {\n\treturn doc.createComment(body);\n}\n\n// ? removes if !recycled\nexport function nextSib(sib) {\n\treturn sib.nextSibling;\n}\n\n// ? removes if !recycled\nexport function prevSib(sib) {\n\treturn sib.previousSibling;\n}\n\n// TODO: this should collect all deep proms from all hooks and return Promise.all()\nfunction deepNotifyRemove(node) {\n\tvar hooks = node.hooks, vm = node.vm;\n\n\tvm && vm.hooks && fireHooks(\"willUnmount\", vm);\n\n\tvar res = hooks && fireHooks(\"willRemove\", node);\n\n\tif ((node.flags & DEEP_REMOVE) === DEEP_REMOVE && isArr(node.body)) {\n\t\tfor (var i = 0; i < node.body.length; i++)\n\t\t\tdeepNotifyRemove(node.body[i]);\n\t}\n\n\treturn res;\n}\n\nfunction _removeChild(parEl, el, immediate) {\n\tvar node = el._node, hooks = node.hooks, vm = node.vm;\n\n\tif ((node.flags & DEEP_REMOVE) === DEEP_REMOVE && isArr(node.body)) {\n\t//\tvar parEl = node.el;\n\t\tfor (var i = 0; i < node.body.length; i++)\n\t\t\t_removeChild(el, node.body[i].el);\n\t}\n\n\tparEl.removeChild(el);\n\n\thooks && fireHooks(\"didRemove\", node, null, immediate);\n\n\tvm && vm.hooks && fireHooks(\"didUnmount\", vm, null, immediate);\n}\n\n// todo: should delay parent unmount() by returning res prom?\nexport function removeChild(parEl, el) {\n\tvar node = el._node, hooks = node.hooks;\n\n\tvar res = deepNotifyRemove(node);\n\n\tif (res != null && isProm(res))\n\t\tres.then(curry(_removeChild, [parEl, el, true]));\n\telse\n\t\t_removeChild(parEl, el);\n}\n\nexport function clearChildren(parent) {\n\tvar parEl = parent.el;\n\n\tif ((parent.flags & DEEP_REMOVE) === 0)\n\t\tparEl.textContent = null;\n\telse {\n\t\twhile (parEl.firstChild)\n\t\t\tremoveChild(parEl, parEl.firstChild);\n\t}\n}\n\n// todo: hooks\nexport function insertBefore(parEl, el, refEl) {\n\tvar node = el._node, hooks = node.hooks, inDom = el.parentNode != null;\n\n\t// el === refEl is asserted as a no-op insert called to fire hooks\n\tvar vm = (el === refEl || !inDom) && node.vm;\n\n\tvm && vm.hooks && fireHooks(\"willMount\", vm);\n\n\thooks && fireHooks(inDom ? \"willReinsert\" : \"willInsert\", node);\n\tparEl.insertBefore(el, refEl);\n\thooks && fireHooks(inDom ? \"didReinsert\" : \"didInsert\", node);\n\n\tvm && vm.hooks && fireHooks(\"didMount\", vm);\n}\n\nexport function insertAfter(parEl, el, refEl) {\n\tinsertBefore(parEl, el, refEl ? nextSib(refEl) : null);\n}","import { noop, assignObj } from '../utils';\n\nexport const globalCfg = {\n\tonevent: noop,\n};\n\nexport function config(newCfg) {\n\tassignObj(globalCfg, newCfg);\n}","import { isArr, isFunc, cmpArr } from '../utils';\nimport { closestVNode } from './dom';\nimport { getVm } from './utils';\nimport { globalCfg } from './config';\nimport { devNotify } from \"./addons/devmode\";\n\nfunction bindEv(el, type, fn) {\n//\tDEBUG && console.log(\"addEventListener\");\n\tel[type] = fn;\n}\n\nfunction handle(e, fn, args) {\n\tvar node = closestVNode(e.target);\n\tvar vm = getVm(node);\n\tvar out = fn.apply(null, args.concat(e, node, vm));\n\tglobalCfg.onevent.apply(null, [e, node, vm].concat(args));\n\n\tif (out === false) {\n\t\te.preventDefault();\n\t\te.stopPropagation();\n\t}\n}\n\nfunction wrapHandler(fn, args) {\n//\tconsole.log(\"wrapHandler\");\n\n\treturn function wrap(e) {\n\t\thandle(e, fn, args);\n\t};\n}\n\n// delagated handlers {\".moo\": [fn, a, b]}, {\".moo\": fn}\nfunction wrapHandlers(hash) {\n//\tconsole.log(\"wrapHandlers\");\n\n\treturn function wrap(e) {\n\t\tfor (var sel in hash) {\n\t\t\tif (e.target.matches(sel)) {\n\t\t\t\tvar hnd = hash[sel];\n\t\t\t\tvar isarr = isArr(hnd);\n\t\t\t\tvar fn = isarr ? hnd[0] : hnd;\n\t\t\t\tvar args = isarr ? hnd.slice(1) : [];\n\n\t\t\t\thandle(e, fn, args);\n\t\t\t}\n\t\t}\n\t}\n}\n\n// could merge with on*\n\nexport function patchEvent(node, name, nval, oval) {\n\tif (nval === oval)\n\t\treturn;\n\n\tif (_DEVMODE) {\n\t\tif (isFunc(nval) && isFunc(oval) && oval.name == nval.name)\n\t\t\tdevNotify(\"INLINE_HANDLER\", [node, oval, nval]);\n\t}\n\n\tvar el = node.el;\n\n\t// param'd eg onclick: [myFn, 1, 2, 3...]\n\tif (isArr(nval)) {\n\t\tif (_DEVMODE) {\n\t\t\tif (oval != null && !isArr(oval))\n\t\t\t\tdevNotify(\"MISMATCHED_HANDLER\", [node, oval, nval]);\n\t\t}\n\t\tvar diff = oval == null || !cmpArr(nval, oval);\n\t\tdiff && bindEv(el, name, wrapHandler(nval[0], nval.slice(1)));\n\t}\n\t// basic onclick: myFn (or extracted)\n\telse if (isFunc(nval) && nval !== oval) {\n\t\tif (_DEVMODE) {\n\t\t\tif (oval != null && !isFunc(oval))\n\t\t\t\tdevNotify(\"MISMATCHED_HANDLER\", [node, oval, nval]);\n\t\t}\n\t\tbindEv(el, name, wrapHandler(nval, []));\n\t}\n\t// delegated onclick: {\".sel\": myFn} & onclick: {\".sel\": [myFn, 1, 2, 3]}\n\telse\t\t// isPlainObj, TODO:, diff with old/clean\n\t\tbindEv(el, name, wrapHandlers(nval));\n}","import { isStyleProp, isSplProp, isEvProp, isDynProp, getVm } from './utils';\nimport { isFunc, emptyObj } from '../utils';\nimport { patchStyle } from './patchStyle';\nimport { patchEvent } from './patchEvent';\nimport { isStream, hookStream } from './addons/stubs';\nimport { devNotify } from \"./addons/devmode\";\n\nexport function remAttr(node, name, asProp) {\n\tif (asProp)\n\t\tnode.el[name] = \"\";\n\telse\n\t\tnode.el.removeAttribute(name);\n}\n\n// setAttr\n// diff, \".\", \"on*\", bool vals, skip _*, value/checked/selected selectedIndex\nexport function setAttr(node, name, val, asProp, initial) {\n\tvar el = node.el;\n\n\tif (val == null)\n\t\t!initial && remAttr(node, name);\t\t//, asProp?  // will also removeAttr of style: null\n\telse if (node.ns != null)\n\t\tel.setAttribute(name, val);\n\telse if (name === \"class\")\n\t\tel.className = val;\n\telse if (name === \"id\" || typeof val === \"boolean\" || asProp)\n\t\tel[name] = val;\n\telse if (name[0] === \".\")\n\t\tel[name.substr(1)] = val;\n\telse\n\t\tel.setAttribute(name, val);\n}\n\nexport function patchAttrs(vnode, donor, initial) {\n\tconst nattrs = vnode.attrs || emptyObj;\n\tconst oattrs = donor.attrs || emptyObj;\n\n\tif (nattrs === oattrs) {\n\t\tif (_DEVMODE)\n\t\t\tdevNotify(\"REUSED_ATTRS\", [vnode]);\n\t}\n\telse {\n\t\tfor (var key in nattrs) {\n\t\t\tvar nval = nattrs[key];\n\t\t\tvar isDyn = isDynProp(vnode.tag, key);\n\t\t\tvar oval = isDyn ? vnode.el[key] : oattrs[key];\n\n\t\t\tif (isStream(nval))\n\t\t\t\tnattrs[key] = nval = hookStream(nval, getVm(vnode));\n\n\t\t\tif (nval === oval) {}\n\t\t\telse if (isStyleProp(key))\n\t\t\t\tpatchStyle(vnode, donor);\n\t\t\telse if (isSplProp(key)) {}\n\t\t\telse if (isEvProp(key))\n\t\t\t\tpatchEvent(vnode, key, nval, oval);\n\t\t\telse\n\t\t\t\tsetAttr(vnode, key, nval, isDyn, initial);\n\t\t}\n\n\t\t// TODO: handle key[0] === \".\"\n\t\t// should bench style.cssText = \"\" vs removeAttribute(\"style\")\n\t\tfor (var key in oattrs) {\n\t\t\t!(key in nattrs) &&\n\t\t\t!isSplProp(key) &&\n\t\t\tremAttr(vnode, key, isDynProp(vnode.tag, key) || isEvProp(key));\n\t\t}\n\t}\n}","import { ELEMENT, TEXT, COMMENT, VVIEW, VMODEL } from './VTYPES';\nimport { ViewModel } from './ViewModel';\n\nexport function createView(view, model, key, opts) {\n\tif (view.type === VVIEW) {\n\t\tmodel\t= view.model;\n\t\tkey\t\t= view.key;\n\t\topts\t= view.opts;\n\t\tview\t= view.view;\n\t}\n\telse if (view.prototype._isClass)\n\t\treturn new view(model, key, opts);\n\n\treturn new ViewModel(view, model, key, opts);\n}","import { ELEMENT, TEXT, COMMENT, VVIEW, VMODEL } from './VTYPES';\nimport { isArr, emptyObj } from '../utils';\nimport { patchAttrs } from './patchAttrs';\nimport { createView } from './createView';\nimport { LAZY_LIST } from './initElementNode';\n//import { XML_NS, XLINK_NS } from './defineSvgElement';\nimport { createElement, createTextNode, createComment, insertBefore } from './dom';\n\nexport function hydrateBody(vnode) {\n\tfor (var i = 0; i < vnode.body.length; i++) {\n\t\tvar vnode2 = vnode.body[i];\n\t\tvar type2 = vnode2.type;\n\n\t\t// ELEMENT,TEXT,COMMENT\n\t\tif (type2 <= COMMENT)\n\t\t\tinsertBefore(vnode.el, hydrate(vnode2));\t\t// vnode.el.appendChild(hydrate(vnode2))\n\t\telse if (type2 === VVIEW) {\n\t\t\tvar vm = createView(vnode2.view, vnode2.model, vnode2.key, vnode2.opts)._redraw(vnode, i, false);\t\t// todo: handle new model updates\n\t\t\ttype2 = vm.node.type;\n\t\t\tinsertBefore(vnode.el, hydrate(vm.node));\n\t\t}\n\t\telse if (type2 === VMODEL) {\n\t\t\tvar vm = vnode2.vm;\n\t\t\tvm._redraw(vnode, i);\t\t\t\t\t// , false\n\t\t\ttype2 = vm.node.type;\n\t\t\tinsertBefore(vnode.el, vm.node.el);\t\t// , hydrate(vm.node)\n\t\t}\n\t}\n}\n\n//  TODO: DRY this out. reusing normal patch here negatively affects V8's JIT\nexport function hydrate(vnode, withEl) {\n\tif (vnode.el == null) {\n\t\tif (vnode.type === ELEMENT) {\n\t\t\tvnode.el = withEl || createElement(vnode.tag, vnode.ns);\n\n\t\t//\tif (vnode.tag === \"svg\")\n\t\t//\t\tvnode.el.setAttributeNS(XML_NS, 'xmlns:xlink', XLINK_NS);\n\n\t\t\tif (vnode.attrs != null)\n\t\t\t\tpatchAttrs(vnode, emptyObj, true);\n\n\t\t\tif ((vnode.flags & LAZY_LIST) === LAZY_LIST)\t// vnode.body instanceof LazyList\n\t\t\t\tvnode.body.body(vnode);\n\n\t\t\tif (isArr(vnode.body))\n\t\t\t\thydrateBody(vnode);\n\t\t\telse if (vnode.body != null && vnode.body !== \"\") {\n\t\t\t\tif (vnode.raw)\n\t\t\t\t\tvnode.el.innerHTML = vnode.body;\n\t\t\t\telse\n\t\t\t\t\tvnode.el.textContent = vnode.body;\n\t\t\t}\n\t\t}\n\t\telse if (vnode.type === TEXT)\n\t\t\tvnode.el = withEl || createTextNode(vnode.body);\n\t\telse if (vnode.type === COMMENT)\n\t\t\tvnode.el = withEl || createComment(vnode.body);\n\t}\n\n\tvnode.el._node = vnode;\n\n\treturn vnode.el;\n}","import { emptyObj } from '../utils';\nimport { hydrate } from './hydrate';\nimport { prevSib, nextSib, insertBefore, insertAfter, removeChild } from './dom';\nimport { devNotify } from \"./addons/devmode\";\n\nfunction nextNode(node, body) {\n\treturn body[node.idx + 1];\n}\n\nfunction prevNode(node, body) {\n\treturn body[node.idx - 1];\n}\n\nfunction parentNode(node) {\n\treturn node.parent;\n}\n\nfunction cmpElNodeIdx(a, b) {\n\treturn a._node.idx - b._node.idx;\n}\n\nfunction tmpEdges(fn, parEl, lftSib, rgtSib) {\n\t// get outer immute edges\n\tvar lftLft = prevSib(lftSib);\n\tvar rgtRgt = nextSib(rgtSib);\n\n\tfn(lftLft, rgtRgt);\n\n\treturn {\n\t\tlftSib: lftLft ? nextSib(lftLft) : parEl.firstChild,\n\t\trgtSib: rgtRgt ? prevSib(rgtRgt) : parEl.lastChild,\n\t};\n}\n\nfunction headTailTry(parEl, lftSib, lftNode, rgtSib, rgtNode) {\n\tvar areAdjacent\t= rgtNode.idx === lftNode.idx + 1;\n\tvar headToTail = areAdjacent ? false : lftSib._node === rgtNode;\n\tvar tailToHead = areAdjacent ? true  : rgtSib._node === lftNode;\n\n\tif (headToTail || tailToHead) {\n\t\treturn tmpEdges(function(lftLft, rgtRgt) {\n\t\t\tif (tailToHead)\n\t\t\t\tinsertBefore(parEl, rgtSib, lftSib);\n\n\t\t\tif (headToTail)\n\t\t\t\tinsertBefore(parEl, lftSib, rgtRgt);\n\t\t}, parEl, lftSib, rgtSib);\n\t}\n\n\treturn null;\n}\n\n// init vm,\n\n// selection sort of DOM (cause move cost >> cmp cost)\n// todo: skip removed\nfunction sortDOM(parEl, lftSib, rgtSib, cmpFn) {\n//\tDEBUG && console.log(\"selection sort!\");\n\n\treturn tmpEdges(function(lftLft, rgtRgt) {\n\t\tvar min;\n\n\t\tfor (var i = lftSib; i !== rgtRgt; i = nextSib(i)) {\n\t\t\tlftSib = min = i;\n\n\t\t\tfor (var j = nextSib(i); j !== rgtRgt; j = nextSib(j)) {\n\t\t\t\tif (cmpFn(min, j) > 0)\n\t\t\t\t\tmin = j;\n\t\t\t}\n\n\t\t\tif (min === i)\n\t\t\t\tcontinue;\n\n\t\t\tinsertBefore(parEl, min, lftSib);\n\n\t\t\ti = min;\n\t\t}\n\t}, parEl, lftSib, rgtSib);\n}\n\nfunction cmpElNodeIdx(a, b) {\n\treturn a._node.idx - b._node.idx;\n}\n\nexport function syncChildren(node, donor) {\n\tvar parEl\t\t= node.el,\n\t\tbody\t\t= node.body,\n\t\tobody\t\t= donor.body,\n\t\tlftNode\t\t= body[0],\n\t\trgtNode\t\t= body[body.length - 1],\n\t\tlftSib\t\t= ((obody)[0] || emptyObj).el,\n\t//\tlftEnd\t\t= prevSib(lftSib),\n\t\trgtSib\t\t= (obody[obody.length - 1] || emptyObj).el,\n\t//\trgtEnd\t\t= nextSib(rgtSib),\n\t\tnewSibs,\n\t\ttmpSib,\n\t\tlsNode,\n\t\trsNode;\n\n\tconverge:\n\twhile (1) {\n//\t\tfrom_left:\n\t\twhile (1) {\n\t\t\t// remove any non-recycled sibs whose el.node has the old parent\n\t\t\tif (lftSib) {\n\t\t\t\t// skip dom elements not created by domvm\n\t\t\t\tif ((lsNode = lftSib._node) == null) {\n\t\t\t\t\tif (_DEVMODE)\n\t\t\t\t\t\tdevNotify(\"FOREIGN_ELEMENT\", [lftSib]);\n\n\t\t\t\t\tlftSib = nextSib(lftSib);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (parentNode(lsNode) !== node) {\n\t\t\t\t\ttmpSib = nextSib(lftSib);\n\t\t\t\t\tlsNode.vm != null ? lsNode.vm.unmount(true) : removeChild(parEl, lftSib);\n\t\t\t\t\tlftSib = tmpSib;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (lftNode == null)\t\t// reached end\n\t\t\t\tbreak converge;\n\t\t\telse if (lftNode.el == null) {\n\t\t\t\tinsertBefore(parEl, hydrate(lftNode), lftSib);\t\t// lftNode.vm != null ? lftNode.vm.mount(parEl, false, true, lftSib) :\n\t\t\t\tlftNode = nextNode(lftNode, body);\n\t\t\t}\n\t\t\telse if (lftNode.el === lftSib) {\n\t\t\t\tlftNode = nextNode(lftNode, body);\n\t\t\t\tlftSib = nextSib(lftSib);\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\n//\t\tfrom_right:\n\t\twhile (1) {\n\t\t//\tif (rgtSib === lftEnd)\n\t\t//\t\tbreak converge;\n\n\t\t\tif (rgtSib) {\n\t\t\t\tif ((rsNode = rgtSib._node) == null) {\n\t\t\t\t\tif (_DEVMODE)\n\t\t\t\t\t\tdevNotify(\"FOREIGN_ELEMENT\", [rgtSib]);\n\n\t\t\t\t\trgtSib = prevSib(rgtSib);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (parentNode(rsNode) !== node) {\n\t\t\t\t\ttmpSib = prevSib(rgtSib);\n\t\t\t\t\trsNode.vm != null ? rsNode.vm.unmount(true) : removeChild(parEl, rgtSib);\n\t\t\t\t\trgtSib = tmpSib;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rgtNode === lftNode)\t\t// converged\n\t\t\t\tbreak converge;\n\t\t\telse if (rgtNode.el == null) {\n\t\t\t\tinsertAfter(parEl, hydrate(rgtNode), rgtSib);\t\t// rgtNode.vm != null ? rgtNode.vm.mount(parEl, false, true, nextSib(rgtSib) :\n\t\t\t\trgtNode = prevNode(rgtNode, body);\n\t\t\t}\n\t\t\telse if (rgtNode.el === rgtSib) {\n\t\t\t\trgtNode = prevNode(rgtNode, body);\n\t\t\t\trgtSib = prevSib(rgtSib);\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (newSibs = headTailTry(parEl, lftSib, lftNode, rgtSib, rgtNode)) {\n\t\t\tlftSib = newSibs.lftSib;\n\t\t\trgtSib = newSibs.rgtSib;\n\t\t\tcontinue;\n\t\t}\n\n\t\tnewSibs = sortDOM(parEl, lftSib, rgtSib, cmpElNodeIdx);\n\t\tlftSib = newSibs.lftSib;\n\t\trgtSib = newSibs.rgtSib;\n\t}\n}","import { noop, isArr, cmpArr, cmpObj } from '../../utils';\nimport { preProc } from '../preProc';\nimport { KEYED_LIST } from '../initElementNode';\n\nexport function lazyList(items, cfg) {\n\treturn new LazyList(items, cfg.key, cfg.diff, cfg.tpl);\n}\n\nexport function LazyList(items, key, diff, tpl) {\n\tthis.items = items;\n\tthis.length = items.length;\n\tthis.key = function(i) {\n\t\treturn key(items[i], i);\n\t};\n\tthis.diff = function(i, donor) {\n\t\tvar newVals = diff(items[i], i);\n\t\tif (donor == null)\n\t\t\treturn newVals;\n\t\tvar oldVals = donor._diff;\n\t\tvar same = newVals === oldVals || isArr(oldVals) ? cmpArr(newVals, oldVals) : cmpObj(newVals, oldVals);\n\t\treturn same || newVals;\n\t};\n\tthis.map(tpl);\n}\n\nLazyList.prototype = {\n\tconstructor: LazyList,\n\n\titems: null,\n\tlength: null,\n\tkey: null,\t\t// defaults to returning item identity (or position?)\n\tdiff: null,\t\t// returns 0\n\ttpl: null,\t\t// or return some error tpl\n\tmap: function(tpl) {\n\t\tthis.tpl = function(i) {\n\t\t\treturn tpl(this.items[i]);\n\t\t};\n\t\treturn this;\n\t},\n\tbody: function(vnode) {\n\t\tvar items = this.items;\n\n\t\tvar nbody = Array(items.length);\n\n\t\tfor (var i = 0; i < items.length; i++) {\n\t\t\tvar vnode2 = this.tpl(i);\n\n\t\t//\tif ((vnode.flags & KEYED_LIST) === KEYED_LIST && self. != null)\n\t\t//\t\tvnode2.key = getKey(item);\n\n\t\t\tvnode2._diff = this.diff(i);\t\t\t// holds oldVals for cmp\n\n\t\t\tnbody[i] = vnode2;\n\n\t\t\t// run preproc pass (should this be just preProc in above loop?) bench\n\t\t\tpreProc(vnode2, vnode, i);\n\t\t}\n\n\t\t// replace List with generated body\n\t\tvnode.body = nbody;\n\t}\n};","import { ELEMENT, TEXT, COMMENT, VVIEW, VMODEL } from './VTYPES';\nimport { isArr, binaryKeySearch } from '../utils';\nimport { preProc } from './preProc';\nimport { hydrateBody } from './hydrate';\nimport { clearChildren } from './dom';\nimport { syncChildren } from './syncChildren';\nimport { fireHooks } from './hooks';\nimport { patchAttrs } from './patchAttrs';\nimport { createView } from './createView';\nimport { LazyList } from './addons/lazyList';\nimport { FIXED_BODY, DEEP_REMOVE, KEYED_LIST, LAZY_LIST } from './initElementNode';\n\nfunction findDonor(n, obody, fromIdx, toIdx) {\t\t// pre-tested isView?\n\tfor (; fromIdx < obody.length; fromIdx++) {\n\t\tvar o = obody[fromIdx];\n\n\t\tif (n.type === VVIEW && o.vm != null) {\t\t\t// also ignore recycled/moved?\n\t\t\tvar ov = o.vm;\n\n\t\t\t// match by key & viewFn\n\t\t\tif (ov.view === n.view && ov.key === n.key)\n\t\t\t\treturn o;\n\t\t}\n\n\t\tif (o.el._node !== o || n.tag !== o.tag || n.type !== o.type || n.vm !== o.vm)\n\t\t\tcontinue;\n\n\t\t// if n.view\n\n\t\tif (n.key === o.key)\t\t// accounts for matching & both null\n\t\t\treturn o;\n\t\telse {\n\t\t\t//\n\t\t\tif (o.key == null) {\n\t\t\t\treturn o;\n\t\t\t}\n\t\t\t// n.key && o.key, ident?\n\t\t\telse {\n\t\t\t//\tconsole.log(n.key, o.key);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn null;\n}\n\n// list must be a sorted list of vnodes by key\nfunction findListDonor(n, list) {\n\tvar idx = binaryKeySearch(list, n.key);\n\treturn idx > -1 ? list[idx] : null;\n}\n\nfunction findDonor2(n, obody, fromIdx) {\n\tfor (; fromIdx < obody.length; fromIdx++) {\n\t\tvar o = obody[fromIdx];\n\n\t\tif (o.key === n.key)\n\t\t\treturn o;\n\t}\n\n\treturn null;\n}\n\n// have it handle initial hydrate? !donor?\n// types (and tags if ELEM) are assumed the same, and donor exists\nexport function patch(vnode, donor) {\n\tdonor.hooks && fireHooks(\"willRecycle\", donor, vnode);\n\n\tvar el = vnode.el = donor.el;\n\n\tvar obody = donor.body;\n\tvar nbody = vnode.body;\n\n\tel._node = vnode;\n\n\t// \"\" => \"\"\n\tif (vnode.type === TEXT && nbody !== obody) {\n\t\tel.nodeValue = nbody;\n\t\treturn;\n\t}\n\n\tif (vnode.attrs != null || donor.attrs != null)\n\t\tpatchAttrs(vnode, donor);\n\n\t// patch events\n\n\tvar oldIsArr = isArr(obody);\n\tvar newIsArr = isArr(nbody);\n\n//\tvar nonEqNewBody = nbody != null && nbody !== obody;\n\n\tif (oldIsArr) {\n\t\t// [] => []\n\t\tif (newIsArr || (vnode.flags & LAZY_LIST) === LAZY_LIST) {\t\t// nbody instanceof LazyList\n\t\t//\tconsole.log('[] => []', obody, nbody);\n\t\t\t// graft children\n\t\t\tpatchChildren(vnode, donor);\n\t\t}\n\t\t// [] => \"\" | null\n\t\telse if (nbody !== obody) {\n\t\t\t// needs cleanup pass?\n\t\t//\tconsole.log('[] => \"\"', obody, nbody);\n\n\t\t\tif (nbody != null) {\n\t\t\t\tif (vnode.raw)\n\t\t\t\t\tel.innerHTML = nbody;\n\t\t\t\telse\n\t\t\t\t\tel.textContent = nbody;\n\t\t\t}\n\t\t\telse\n\t\t\t\tclearChildren(donor);\n\t\t}\n\t}\n\telse {\n\t\t// \"\" | null => []\n\t\tif (newIsArr) {\n\t\t//\tconsole.log('\"\" => []', obody, nbody);\t// hydrate new here?\n\t\t\tclearChildren(donor);\n\t\t\thydrateBody(vnode);\n\t\t}\n\t\t// \"\" | null => \"\" | null\n\t\telse if (nbody !== obody) {\n\t\t//\tconsole.log('\"\" => \"\"', donor, vnode);\n\n\t\t\tif (vnode.raw)\n\t\t\t\tel.innerHTML = nbody;\n\t\t\telse if (donor.raw)\n\t\t\t\tel.textContent = nbody;\n\t\t\telse if (el.firstChild)\n\t\t\t\tel.firstChild.nodeValue = nbody;\n\t\t\telse\n\t\t\t\tel.textContent = nbody;\n\t\t}\n\t}\n\n\tdonor.hooks && fireHooks(\"didRecycle\", donor, vnode);\n}\n\nfunction sortByKey(a, b) {\n\treturn a.key > b.key ? 1 : a.key < b.key ? -1 : 0;\n}\n\nfunction findAndPatch(node2, i, parent, list, find, fromIdx, donor2) {\n\tvar type2 = node2.type;\n\n\t// ELEMENT,TEXT,COMMENT\n\tif (type2 <= COMMENT) {\n\t\tif (donor2 = donor2 || find(node2, list, fromIdx))\n\t\t\tpatch(node2, donor2);\n\t}\n\telse if (type2 === VVIEW) {\n\t\tif (donor2 = donor2 || find(node2, list, fromIdx))\t\t// update/moveTo\n\t\t\tvar vm = donor2.vm._update(node2.model, parent, i);\t\t// withDOM\n\t\telse\n\t\t\tvar vm = createView(node2.view, node2.model, node2.key, node2.opts)._redraw(parent, i, false);\t// createView, no dom (will be handled by sync below)\n\n\t\ttype2 = vm.node.type;\n\t}\n\telse if (type2 === VMODEL) {\n\t\tvar vm = node2.vm._update(node2.model, parent, i);\n\t\ttype2 = vm.node.type;\n\t}\n\n\treturn donor2;\n}\n\n// larger qtys of KEYED_LIST children will use binary search\nconst SEQ_SEARCH_MAX = 100;\n\n// [] => []\nfunction patchChildren(vnode, donor) {\n\tvar nbody = vnode.body,\n\t\tnlen = nbody.length,\n\t\tobody = donor.body,\n\t\tolen = obody.length,\n\t\tfixedBody = (donor.flags & FIXED_BODY) === FIXED_BODY,\n\t\tdomSync = donor.type === ELEMENT && !fixedBody;\n\n\tif (domSync && nlen === 0) {\n\t\tclearChildren(donor);\n\t\tif ((vnode.flags & LAZY_LIST) === LAZY_LIST)\n\t\t\tvnode.body = [];    // nbody.tpl(all);\n\t\treturn;\n\t}\n\n\tvar keyedList = (donor.flags & KEYED_LIST) === KEYED_LIST;\n\n\t// use binary search for non-static keyed lists of large length\n\tif (keyedList && !fixedBody && olen > SEQ_SEARCH_MAX) {\n\t\tvar list = donor.body.slice();\n\t\tlist.sort(sortByKey);\n\t\tvar find = findListDonor;\n\t}\n\telse {\n\t\tvar list = donor.body;\n\t\tvar find = findDonor;\n\t}\n\n\tvar donor2,\n\t\tnode2,\n\t\tdiffRes,\n\t\tremake,\n\t\ttype2,\n\t\tfromIdx = 0;\t\t\t\t// first unrecycled node (search head)\n\n\t// list should always be keyed, but FIXED_BODY prevents binary search sorting\n\tif (keyedList && (donor.flags & LAZY_LIST) === LAZY_LIST) {\n\t\tfind = findDonor2;\n\n\t\tvar fnode2 = {key: null};\n\n\t\tvar nbodyNew = Array(nbody.length);\n\n\t\tfor (var i = 0; i < nlen; i++) {\n\t\t\tremake = false;\n\t\t\tdiffRes = null;\n\n\t\t\tfnode2.key = nbody.key(i);\n\t\t\tdonor2 = find(fnode2, list, fromIdx);\n\n\t\t\tif (donor2 != null) {\n\t\t\t\tdiffRes = nbody.diff(i, donor2);\n\n\t\t\t\t// diff returns same, so cheaply adopt vnode without patching\n\t\t\t\tif (diffRes === true) {\n\t\t\t\t\tnode2 = donor2;\n\t\t\t\t\tnode2.parent = vnode;\n\t\t\t\t\tnode2.idx = i;\n\t\t\t\t}\n\t\t\t\t// diff returns new diffVals, so generate new vnode & patch\n\t\t\t\telse\n\t\t\t\t\tremake = true;\n\t\t\t}\n\t\t\telse\n\t\t\t\tremake = true;\n\n\t\t\tif (remake) {\n\t\t\t\tnode2 = nbody.tpl(i);\n\t\t\t\tpreProc(node2, vnode, i);\n\n\t\t\t\tnode2._diff = diffRes != null ? diffRes : nbody.diff(i);\n\n\t\t\t\tif (donor2 != null)\n\t\t\t\t\tpatch(node2, donor2);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// TODO: flag tmp FIXED_BODY on unchanged nodes?\n\n\t\t\t\t// domSync = true;\t\tif any idx changes or new nodes added/removed\n\t\t\t}\n\n\t\t\tnbodyNew[i] = node2;\n\n\t\t\t// to keep search space small, if donation is non-contig, move node fwd?\n\t\t\t// re-establish contigindex\n\t\t\tif (find !== findListDonor && donor2 != null && donor2.idx === fromIdx)\n\t\t\t\tfromIdx++;\n\t\t}\n\n\t\t// replace List w/ new body\n\t\tvnode.body = nbodyNew;\n\t}\n\telse {\n\t\tfor (var i = 0; i < nlen; i++) {\n\t\t\tvar node2 = nbody[i];\n\t\t\tvar type2 = node2.type;\n\n\t\t\t// ELEMENT,TEXT,COMMENT\n\t\t\tif (type2 <= COMMENT) {\n\t\t\t\tif (donor2 = find(node2, list, fromIdx))\n\t\t\t\t\tpatch(node2, donor2);\n\t\t\t}\n\t\t\telse if (type2 === VVIEW) {\n\t\t\t\tif (donor2 = find(node2, list, fromIdx))\t\t// update/moveTo\n\t\t\t\t\tvar vm = donor2.vm._update(node2.model, vnode, i);\t\t// withDOM\n\t\t\t\telse\n\t\t\t\t\tvar vm = createView(node2.view, node2.model, node2.key, node2.opts)._redraw(vnode, i, false);\t// createView, no dom (will be handled by sync below)\n\n\t\t\t\ttype2 = vm.node.type;\n\t\t\t}\n\t\t\telse if (type2 === VMODEL) {\n\t\t\t\tvar vm = node2.vm._update(node2.model, vnode, i);\n\t\t\t\ttype2 = vm.node.type;\n\t\t\t}\n\n\t\t\t// to keep search space small, if donation is non-contig, move node fwd?\n\t\t\t// re-establish contigindex\n\t\t\tif (find !== findListDonor && donor2 != null && donor2.idx === fromIdx)\n\t\t\t\tfromIdx++;\n\t\t}\n\t}\n\n\tdomSync && syncChildren(vnode, donor);\n}","import { patch } from \"./patch\";\nimport { hydrate } from \"./hydrate\";\nimport { preProc } from \"./preProc\";\nimport { isArr, isPlainObj, isFunc, isProm, cmpArr, cmpObj, assignObj, curry, raft } from \"../utils\";\nimport { repaint, getVm } from \"./utils\";\nimport { insertBefore, removeChild, nextSib, clearChildren } from \"./dom\";\nimport { didQueue, fireHooks } from \"./hooks\";\nimport { devNotify } from \"./addons/devmode\";\n\nexport function ViewModel(view, model, key, opts) {\t\t\t// parent, idx, parentVm\n\tvar vm = this;\n\n\tvm.view = view;\n\tvm.model = model;\n\tvm.key = key == null ? model : key;\n\n\tif (_DEVMODE) {\n\t\tif (model != null && model === key)\n\t\t\tdevNotify(\"AUTOKEYED_VIEW\", [vm, model]);\n\t}\n\n\tif (!view.prototype._isClass) {\n\t\tvar out = view.call(vm, vm, model, key, opts);\n\n\t\tif (isFunc(out))\n\t\t\tvm.render = out;\n\t\telse {\n\t\t\tif (out.diff) {\n\t\t\t\tvm.diff(out.diff);\n\t\t\t\tdelete out.diff;\n\t\t\t}\n\n\t\t\tassignObj(vm, out);\n\t\t}\n\t}\n\telse {\n\t//\thandle .diff re-definiton\n\t\tvar vdiff = vm.diff;\n\n\t\tif (vdiff != null && vdiff !== ViewModelProto.diff) {\n\t\t\tvm.diff = ViewModelProto.diff.bind(vm);\n\t\t\tvm.diff(vdiff);\n\t\t}\n\t}\n\n\t// remove this?\n\tif (opts) {\n\t\tvm.opts = opts;\n\n\t\tif (opts.hooks)\n\t\t\tvm.hook(opts.hooks);\n\t\tif (opts.diff)\n\t\t\tvm.diff(opts.diff);\n\t}\n\n\t// these must be created here since debounced per view\n\tvm._redrawAsync = raft(_ => vm._redraw());\n\tvm._updateAsync = raft(newModel => vm._update(newModel));\n\n\tvar hooks = vm.hooks;\n\n\tif (hooks && hooks.didInit)\n\t\thooks.didInit.call(vm, vm, model, key, opts);\n\n//\tthis.update(model, parent, idx, parentVm, false);\n\n\t// proc opts, evctx, watch\n\n//\tthis.update = function(model, withRedraw, parent, idx, parentVm) {};\n}\n\nexport const ViewModelProto = ViewModel.prototype = {\n\tconstructor: ViewModel,\n\n\t_isClass: false,\n\n\t// view + key serve as the vm's unique identity\n\tview: null,\n\tkey: null,\n\tmodel: null,\n\topts: null,\n\tnode: null,\n//\tdiff: null,\n//\tdiffLast: null,\t// prior array of diff values\n\thooks: null,\n\trender: null,\n\n//\t_setRef: function() {},\n\n\t// as plugins?\n\tparent: function() {\n\t\treturn getVm(this.node.parent);\n\t},\n\n\troot: function() {\n\t\tvar p = this.node;\n\n\t\twhile (p.parent)\n\t\t\tp = p.parent;\n\n\t\treturn p.vm;\n\t},\n\n\tapi: null,\n\trefs: null,\n\tmount: mount,\n\tunmount: unmount,\n\tredraw: function(sync) {\n\t\tvar vm = this;\n\t\tsync ? vm._redraw() : vm._redrawAsync();\n\t\treturn vm;\n\t},\n\tupdate: function(newModel, sync) {\n\t\tvar vm = this;\n\t\tsync ? vm._update(newModel) : vm._updateAsync(newModel);\n\t\treturn vm;\n\t},\n\n\t_update: updateSync,\n\t_redraw: redrawSync,\t// non-coalesced / synchronous\n\t_redrawAsync: null,\t\t// this is set in constructor per view\n\t_updateAsync: null,\n\n\thook: function(hooks) {\n\t\tthis.hooks = this.hooks || assignObj({}, this.hooks, hooks);\n\t},\n};\n\n\nexport function drainDidHooks(vm) {\n\tif (didQueue.length) {\n\t\trepaint(vm.node);\n\n\t\tvar item;\n\t\twhile (item = didQueue.shift())\n\t\t\titem[0](item[1], item[2]);\n\t}\n}\n\n/*\nfunction isEmptyObj(o) {\n\tfor (var k in o)\n\t\treturn false;\n\treturn true;\n}\n*/\n\nfunction mount(el, isRoot) {\t\t// , asSub, refEl\n\tvar vm = this;\n\n\tif (isRoot) {\n\t\tclearChildren({el: el, flags: 0});\n\n\t\tvm._redraw(null, null, false);\n\n\t\t// if placeholder node doesnt match root tag\n\t\tif (el.nodeName.toLowerCase() !== vm.node.tag) {\n\t\t\thydrate(vm.node);\n\t\t\tinsertBefore(el.parentNode, vm.node.el, el);\n\t\t\tel.parentNode.removeChild(el);\n\t\t}\n\t\telse\n\t\t\tinsertBefore(el.parentNode, hydrate(vm.node, el), el);\n\t}\n\telse {\n\t\tvm._redraw(null, null);\n\n\t\tif (el)\n\t\t\tinsertBefore(el, vm.node.el);\t\t\t// el.appendChild(vm.node.el);\n\t}\n\n\tif (el)\n\t\tdrainDidHooks(vm);\n\n\treturn vm;\n}\n\n// asSub = true means this was called from a sub-routine, so don't drain did* hook queue\n// immediate = true means did* hook will not be queued (usually cause this is a promise resolution)\nfunction unmount(asSub) {\n\tvar vm = this;\n\n\tvar node = vm.node;\n\tvar parEl = node.el.parentNode;\n\n\t// edge bug: this could also be willRemove promise-delayed; should .then() or something to make sure hooks fire in order\n\tremoveChild(parEl, node.el);\n\n\tif (!asSub)\n\t\tdrainDidHooks(vm);\n}\n\n// level, isRoot?\n// newParent, newIdx\n// ancest by ref, by key\nfunction redrawSync(newParent, newIdx, withDOM) {\n\tconst isRedrawRoot = newParent == null;\n\tvar vm = this;\n\tvar isMounted = vm.node && vm.node.el && vm.node.el.parentNode;\n\n\tif (_DEVMODE) {\n\t\t// was mounted (has node and el), but el no longer has parent (unmounted)\n\t\tif (isRedrawRoot && vm.node && vm.node.el && !vm.node.el.parentNode)\n\t\t\tdevNotify(\"UNMOUNTED_REDRAW\", [vm]);\n\t}\n\n\tvar vold = vm.node;\n\n\t// no diff, just re-parent old\n\t// TODO: allow returning vm.node as no-change indicator\n\tif (isMounted && vm._diff != null && vm._diff()) {\n\t\t// will doing this outside of preproc cause de-opt, add shallow opt to preproc?\n\t\tif (vold && newParent) {\n\t\t\tnewParent.body[newIdx] = vold;\n\t\t\tvold.idx = newIdx;\n\t\t\tvold.parent = newParent;\n\t\t}\n\t\treturn vm;\n\t}\n\n\tisMounted && vm.hooks && fireHooks(\"willRedraw\", vm);\n\n\t// todo: test result of willRedraw hooks before clearing refs\n\tvm.refs = null;\n\n\tvar vnew = vm.render.call(vm, vm, vm.model, vm.key);\t\t// vm.opts\n\n\t// always assign vm key to root vnode (this is a de-opt)\n\tif (vm.key !== false && vm.key != null && vnew.key !== vm.key)\n\t\tvnew.key = vm.key;\n\n//\tconsole.log(vm.key);\n\n\tvm.node = vnew;\n\n\tif (newParent) {\n\t\tpreProc(vnew, newParent, newIdx, vm);\n\t\tnewParent.body[newIdx] = vnew;\n\t\t// todo: bubble refs, etc?\n\t}\n\telse if (vold && vold.parent) {\n\t\tpreProc(vnew, vold.parent, vold.idx, vm);\n\t\tvold.parent.body[vold.idx] = vnew;\n\t}\n\telse\n\t\tpreProc(vnew, null, null, vm);\n\n\tif (withDOM !== false) {\n\t\tif (vold) {\n\t\t\t// root node replacement\n\t\t\tif (vold.tag !== vnew.tag) {\n\t\t\t\t// hack to prevent the replacement from triggering mount/unmount\n\t\t\t\tvold.vm = vnew.vm = null;\n\n\t\t\t\tvar parEl = vold.el.parentNode;\n\t\t\t\tvar refEl = nextSib(vold.el);\n\t\t\t\tremoveChild(parEl, vold.el);\n\t\t\t\tinsertBefore(parEl, hydrate(vnew), refEl);\n\n\t\t\t\t// another hack that allows any higher-level syncChildren to set\n\t\t\t\t// reconciliation bounds using a live node\n\t\t\t\tvold.el = vnew.el;\n\n\t\t\t\t// restore\n\t\t\t\tvnew.vm = vm;\n\t\t\t}\n\t\t\telse\n\t\t\t\tpatch(vnew, vold);\n\t\t}\n\t\telse\n\t\t\thydrate(vnew);\n\t}\n\n\tisMounted && vm.hooks && fireHooks(\"didRedraw\", vm);\n\n\tif (isRedrawRoot && isMounted)\n\t\tdrainDidHooks(vm);\n\n\treturn vm;\n}\n\n// withRedraw?\n// this doubles as moveTo\n// will/didUpdate\nfunction updateSync(newModel, newParent, newIdx, withDOM) {\t\t\t// parentVm\n\tvar vm = this;\n\n\tif (newModel != null) {\t\t// && vm.key !== vm.model\n\t\tif (vm.model !== newModel) {\n\t\t\tif (_DEVMODE) {\n\t\t\t\tdevNotify(\"MODEL_REPLACED\", [vm, vm.model, newModel]);\n\t\t\t}\n\t\t\tvm.hooks && fireHooks(\"willUpdate\", vm, newModel);\t\t// willUpdate will be called ahead of willRedraw when model will be replaced\n\t\t\tvm.model = newModel;\n\t\t//\tvm.hooks && fireHooks(\"didUpdate\", vm, newModel);\t\t// should this fire at al?\n\t\t}\n\t}\n\n\t// TODO: prevent redraw from firing?\n\n\treturn vm._redraw(newParent, newIdx, withDOM);\n/*\n\tif (parentVm != null) {\n\t\tvm.parent = parentVm;\n\t\tparentVm.body.push(vm);\n\t}\n*/\n}","import { isPlainObj } from '../utils';\nimport { initElementNode } from './initElementNode';\n\nexport function defineElement(tag, arg1, arg2, flags) {\n\tvar attrs, body;\n\n\tif (arg2 == null) {\n\t\tif (isPlainObj(arg1))\n\t\t\tattrs = arg1;\n\t\telse\n\t\t\tbody = arg1;\n\t}\n\telse {\n\t\tattrs = arg1;\n\t\tbody = arg2;\n\t}\n\n\treturn initElementNode(tag, attrs, body, flags);\n}","import { defineElement } from \"./defineElement\";\n\n//export const XML_NS = \"http://www.w3.org/2000/xmlns/\";\nexport const SVG_NS = \"http://www.w3.org/2000/svg\";\n//export const XLINK_NS = \"http://www.w3.org/1999/xlink\";\n\nexport function defineSvgElement(tag, arg1, arg2, flags) {\n\tvar n = defineElement(tag, arg1, arg2, flags);\n\tn.ns = SVG_NS;\n\treturn n;\n}","import { COMMENT } from './VTYPES';\nimport { VNode } from './VNode';\n\nexport function defineComment(body) {\n\tlet node = new VNode;\n\tnode.type = COMMENT;\n\tnode.body = body;\n\treturn node;\n}","import { VVIEW } from './VTYPES';\n\n// placeholder for declared views\nexport function VView(view, model, key, opts) {\n\tthis.view = view;\n\tthis.model = model;\n\tthis.key = key == null ? model : key;\t// same logic as ViewModel\n\tthis.opts = opts;\n}\n\nVView.prototype = {\n\tconstructor: VView,\n\n\ttype: VVIEW,\n\tview: null,\n\tmodel: null,\n\tkey: null,\n\topts: null,\n};","import { VView } from './VView';\n\nexport function defineView(view, model, key, opts) {\n\treturn new VView(view, model, key, opts);\n}","import { VMODEL } from './VTYPES';\n\n// placeholder for injected ViewModels\nexport function VModel(vm) {\n\tthis.vm = vm;\n}\n\nVModel.prototype = {\n\tconstructor: VModel,\n\n\ttype: VMODEL,\n\tvm: null,\n};","import { VModel } from './VModel';\n\n\nexport function injectView(vm) {\n//\tif (vm.node == null)\n//\t\tvm._redraw(null, null, false);\n\n//\treturn vm.node;\n\n\treturn new VModel(vm);\n}","import { ELEMENT } from './VTYPES';\nimport { VNode } from './VNode';\n\nexport function injectElement(el) {\n\tlet node = new VNode;\n\tnode.type = ELEMENT;\n\tnode.el = node.key = el;\n\treturn node;\n}","import { assignObj } from '../../utils';\nimport { getVm } from '../utils';\nimport { patchAttrs } from '../patchAttrs';\nimport { preProc } from '../preProc';\nimport { patch as fullPatch } from '../patch';\nimport { drainDidHooks } from '../ViewModel';\n\nimport { VNodeProto } from '../VNode';\n\nVNodeProto.patch = function(n) {\n\treturn patch(this, n);\n};\n\n// newNode can be either {class: style: } or full new VNode\n// will/didPatch hooks?\nexport function patch(o, n) {\n\tif (n.type != null) {\n\t\t// no full patching of view roots, just use redraw!\n\t\tif (o.vm != null)\n\t\t\treturn;\n\n\t\tpreProc(n, o.parent, o.idx, null);\n\t\to.parent.body[o.idx] = n;\n//\t\to.parent = o.el = o.body = null;\t\t// helps gc?\n\t\tfullPatch(n, o);\n\t\tdrainDidHooks(getVm(n));\n\t}\n\telse {\n\t\t// TODO: re-establish refs\n\n\t\t// shallow-clone target\n\t\tvar donor = Object.create(o);\n\t\t// fixate orig attrs\n\t\tdonor.attrs = assignObj({}, o.attrs);\n\t\t// assign new attrs into live targ node\n\t\tvar oattrs = assignObj(o.attrs, n);\n\t\t// prepend any fixed shorthand class\n\t\tif (o._class != null) {\n\t\t\tvar aclass = oattrs.class;\n\t\t\toattrs.class = aclass != null && aclass !== \"\" ? o._class + \" \" + aclass : o._class;\n\t\t}\n\n\t\tpatchAttrs(o, donor);\n\t}\n}","import { ViewModelProto } from '../ViewModel';\nimport { isVal, sliceArgs } from '../../utils';\n\nViewModelProto.events = null;\nViewModelProto.emit = emit;\nViewModelProto.on = on;\n\nfunction emit(evName) {\n\tvar targ = this;\n\n\tdo {\n\t\tvar evs = targ.events;\n\t\tvar fn = evs ? evs[evName] : null;\n\n\t\tif (fn) {\n\t\t\tfn.apply(null, sliceArgs(arguments, 1));\n\t\t\tbreak;\n\t\t}\n\n\t} while (targ = targ.parent());\n}\n\nfunction on(evName, fn) {\n\tvar t = this;\n\n\tif (t.events == null)\n\t\tt.events = {};\n\n\tif (isVal(evName))\n\t\tt.events[evName] = fn;\n\telse {\n\t\tvar evs = evName;\n\t\tfor (var evName in evs)\n\t\t\tt.on(evName, evs[evName]);\n\t}\n}\n\nfunction off() {}","import { ViewModelProto } from '../ViewModel';\nimport { isArr } from '../../utils';\t\t// defProp\n\n/*\ndefProp(ViewModelProto, 'body', {\n\tget: function() {\n\t\treturn nextSubVms(this.node, []);\n\t}\n});\n*/\n\nViewModelProto.body = function() {\n\treturn nextSubVms(this.node, []);\n};\n\nfunction nextSubVms(n, accum) {\n\tvar body = n.body;\n\n\tif (isArr(body)) {\n\t\tfor (var i = 0; i < body.length; i++) {\n\t\t\tvar n2 = body[i];\n\n\t\t\tif (n2.vm != null)\n\t\t\t\taccum.push(n2.vm);\n\t\t\telse\n\t\t\t\tnextSubVms(n2, accum);\n\t\t}\n\t}\n\n\treturn accum;\n}","import { VVIEW, VMODEL } from '../VTYPES';\nimport { createView } from '../createView';\nimport { isArr } from '../../utils';\nimport { isStyleProp, isSplProp, isEvProp, isDynProp } from '../utils';\nimport { patchEvent } from '../patchEvent';\nimport { setAttr } from '../patchAttrs';\n\nimport { ViewModelProto } from '../ViewModel';\n\nViewModelProto.attach = function(el) {\n\tvar vm = this;\n\tif (vm.node == null)\n\t\tvm._redraw(null, null, false)\n\n\tattach(vm.node, el);\n\n\treturn vm;\n};\n\n// very similar to hydrate, TODO: dry\nexport function attach(vnode, withEl) {\n\tvnode.el = withEl;\n\twithEl._node = vnode;\n\n\tvar nattrs = vnode.attrs;\n\n\tfor (var key in nattrs) {\n\t\tvar nval = nattrs[key];\n\t\tvar isDyn = isDynProp(vnode.tag, key);\n\n\t\tif (isStyleProp(key) || isSplProp(key)) {}\n\t\telse if (isEvProp(key))\n\t\t\tpatchEvent(vnode, key, nval);\n\t\telse if (nval != null && isDyn)\n\t\t\tsetAttr(vnode, key, nval, isDyn);\n\t}\n\n\tif (isArr(vnode.body)) {\n\t\tvar c = withEl.firstChild;\n\t\tvar i = 0;\n\t\tvar v = vnode.body[i];\n\t\tdo {\n\t\t\tif (v.type === VVIEW)\n\t\t\t\tv = createView(v.view, v.model, v.key, v.opts)._redraw(vnode, i, false).node;\n\t\t\telse if (v.type === VMODEL)\n\t\t\t\tv = v.node || v._redraw(vnode, i, false).node;\n\n\t\t\tattach(v, c);\n\t\t} while ((c = c.nextSibling) && (v = vnode.body[++i]))\n\t}\n}","// NOTE: if adding a new *VNode* type, make it < COMMENT and renumber rest.\n// There are some places that test <= COMMENT to assert if node is a VNode\n\n// VNode types\nexport const ELEMENT\t= 1;\nexport const TEXT\t\t= 2;\nexport const COMMENT\t= 3;\n\n// placeholder types\nexport const VVIEW\t\t= 4;\nexport const VMODEL\t\t= 5;","import { ViewModel } from \"../view/ViewModel\";\nimport { VNode } from \"../view/VNode\";\n\nimport { createView } from \"../view/createView\";\n\nimport { defineElement } from \"../view/defineElement\";\nimport { defineSvgElement } from \"../view/defineSvgElement\";\nimport { defineText } from \"../view/defineText\";\nimport { defineComment } from \"../view/defineComment\";\nimport { defineView } from \"../view/defineView\";\n\nimport { injectView } from \"../view/injectView\";\nimport { injectElement } from \"../view/injectElement\";\n\nimport { lazyList } from '../view/addons/lazyList';\n\nimport { FIXED_BODY, DEEP_REMOVE, KEYED_LIST, LAZY_LIST } from \"../view/initElementNode\";\n\nimport { config } from '../view/config';\n\nexport default {\n\tconfig,\n\n\tViewModel,\n\tVNode,\n\n\tcreateView,\n\n\tdefineElement,\n\tdefineSvgElement,\n\tdefineText,\n\tdefineComment,\n\tdefineView,\n\n\tinjectView,\n\tinjectElement,\n\n\tlazyList,\n\n\tFIXED_BODY,\n\tDEEP_REMOVE,\n\tKEYED_LIST,\n\tLAZY_LIST,\n}","import { ViewModelProto } from '../ViewModel';\nimport { isArr, isFunc, cmpArr, cmpObj } from '../../utils';\n\nViewModelProto._diff = null;\n\n// @vals should be a callback that returns an array or object of values to shallow-compare\n//   if the returned values are the same on subsequent redraw calls, then redraw() is prevented\n// @then may be a callback that will run if arrays dont match and receives the old & new arrays which\n//   it can then use to shallow-patch the top-level vnode if needed (like apply {display: none}) and\n//   return `false` to prevent further redraw()\n// if @cfg is a function, it's assumed to be @vals\nViewModelProto.diff = function(cfg) {\n\tvar vm = this;\n\n\tif (isFunc(cfg))\n\t\tvar getVals = cfg;\n\telse {\n\t\tvar getVals = cfg.vals;\n\t\tvar thenFn = cfg.then;\n\t}\n\n\tvar oldVals = getVals.call(vm, vm, vm.model, vm.key, vm.opts);\n\tvar cmpFn = isArr(oldVals) ? cmpArr : cmpObj;\n\n\tvm._diff = function() {\n\t\tvar newVals = getVals.call(vm, vm, vm.model, vm.key, vm.opts);\n\t\tvar isSame = oldVals === newVals || cmpFn(oldVals, newVals);\n\n\t\tif (!isSame) {\n\t\t\t// thenFn must return false to prevent redraw\n\t\t\tif (thenFn != null && thenFn.call(vm, vm, oldVals, newVals) === false)\n\t\t\t\tisSame = true;\n\n\t\t\toldVals = newVals;\n\t\t}\n\n\t\treturn isSame;\n\t};\n};","import { streamCfg } from './streamCfg';\n\nif (typeof flyd !== \"undefined\") {\n\tstreamCfg({\n\t\tis:\t\ts => flyd.isStream(s),\n\t\tval:\ts => s(),\n\t\tsub:\t(s, fn) => flyd.on(fn, s),\n\t\tunsub:\ts => s.end(true),\n\t});\n}","import { default as mini } from \"./micro\";\n\nimport { streamCfg } from \"../view/addons/streamCfg\";\nimport \"../view/addons/streamFlyd.js\";\n\nmini.streamCfg = streamCfg;\n\nimport { prop } from \"../utils\";\n\nmini.prop = prop;\n\nexport default mini;"],"names":["noop","isSet","val","isPlainObj","constructor","Object","insertArr","targ","arr","pos","rem","splice","apply","concat","isVal","t","isFunc","isProm","then","assignObj","args","arguments","i","length","k","deepSet","path","seg","shift","sliceArgs","offs","push","cmpObj","a","b","cmpArr","const","alen","raft","fn","call","id","ctx","rAF","this","curry","prop","cb","newVal","execCb","undefined","binaryKeySearch","list","item","guess","min","max","key","Math","floor","VNode","defineText","body","let","node","type","TEXT","isEvProp","name","isSplProp","isStyleProp","repaint","el","offsetHeight","isDynProp","tag","attr","getVm","n","emptyObj","vm","parent","autoPx","isNaN","unitlessProps","cssTag","raw","cached","tagCache","cls","match","class","replace","attrs","RE_ATTRS","exec","streamCfg","cfg","isStream","is","streamVal","subStream","sub","unsubStream","unsub","hookStream","s","redrawStream","redraw","initElementNode","flags","ELEMENT","parsed","p","_class","mergedAttrs","_key","_ref","ref","_hooks","hooks","_raw","_data","data","_flags","setRef","split","setDeepRemove","DEEP_REMOVE","preProc","vnew","idx","ownVm","VMODEL","VVIEW","willRemove","willUnmount","isArr","preProcBody","node2","patchStyle","o","ns","style","os","cssText","nn","nv","on","fireHook","did","immediate","didQueue","fireHooks","hook","map","hook2","closestVNode","_node","parentNode","createElement","doc","createElementNS","createTextNode","createComment","nextSib","sib","nextSibling","prevSib","previousSibling","deepNotifyRemove","res","_removeChild","parEl","removeChild","clearChildren","textContent","firstChild","insertBefore","refEl","inDom","insertAfter","config","newCfg","globalCfg","bindEv","handle","e","target","out","onevent","preventDefault","stopPropagation","wrapHandler","wrapHandlers","hash","sel","matches","hnd","isarr","slice","patchEvent","nval","oval","remAttr","asProp","removeAttribute","setAttr","initial","setAttribute","className","substr","patchAttrs","vnode","donor","nattrs","oattrs","isDyn","createView","view","model","opts","prototype","_isClass","ViewModel","hydrateBody","vnode2","type2","COMMENT","hydrate","_redraw","withEl","LAZY_LIST","innerHTML","nextNode","prevNode","tmpEdges","lftSib","rgtSib","lftLft","rgtRgt","lastChild","headTailTry","lftNode","rgtNode","areAdjacent","headToTail","tailToHead","sortDOM","cmpFn","j","cmpElNodeIdx","syncChildren","newSibs","tmpSib","lsNode","rsNode","obody","converge","unmount","lazyList","items","LazyList","diff","tpl","newVals","oldVals","_diff","findDonor","fromIdx","toIdx","ov","findListDonor","findDonor2","patch","nbody","oldIsArr","newIsArr","patchChildren","nodeValue","sortByKey","nlen","olen","fixedBody","FIXED_BODY","domSync","keyedList","KEYED_LIST","SEQ_SEARCH_MAX","sort","find","donor2","diffRes","remake","fnode2","nbodyNew","Array","_update","vdiff","ViewModelProto","bind","render","_redrawAsync","_","_updateAsync","newModel","didInit","drainDidHooks","mount","isRoot","nodeName","toLowerCase","asSub","redrawSync","newParent","newIdx","withDOM","isRedrawRoot","isMounted","vold","refs","updateSync","defineElement","arg1","arg2","defineSvgElement","SVG_NS","defineComment","VView","defineView","VModel","injectView","injectElement","fullPatch","create","aclass","emit","evName","evs","events","nextSubVms","accum","n2","attach","c","v","ENV_DOM","window","requestAnimationFrame","isArray","VNodeProto","animationIterationCount","boxFlex","boxFlexGroup","columnCount","counterIncrement","flex","flexGrow","flexOrder","flexPositive","flexShrink","float","fontWeight","gridColumn","lineHeight","lineClamp","opacity","order","orphans","tabSize","transform","transformOrigin","widows","zIndex","zoom","document","root","api","sync","update","getVals","vals","thenFn","isSame","flyd","end","mini","nano"],"mappings":"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"}