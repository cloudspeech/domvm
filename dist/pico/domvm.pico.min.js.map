{"version":3,"file":"domvm.pico.min.js","sources":["../../src/utils.js","../../src/view/utils.js","../../src/view/addons/stubs.js","../../src/view/patchStyle.js","../../src/view/hooks.js","../../src/view/VNode.js","../../src/view/initElementNode.js","../../src/view/dom.js","../../src/view/config.js","../../src/view/patchEvent.js","../../src/view/patchAttrs.js","../../src/view/createView.js","../../src/view/hydrate.js","../../src/view/syncChildren.js","../../src/view/patch.js","../../src/view/defineText.js","../../src/view/preProc.js","../../src/view/ViewModel.js","../../src/view/defineElement.js","../../src/view/defineSvgElement.js","../../src/view/defineComment.js","../../src/view/VView.js","../../src/view/defineView.js","../../src/view/VModel.js","../../src/view/injectView.js","../../src/view/injectElement.js","../../src/view/VTYPES.js","../../src/builds/pico.js"],"sourcesContent":["export const ENV_DOM = typeof window !== \"undefined\";\nexport const TRUE = true;\nconst win = ENV_DOM ? window : {};\nconst rAF = win.requestAnimationFrame;\n\nexport const emptyObj = {};\n\nexport function noop() {};\n\nexport const isArr = Array.isArray;\n\nexport function isSet(val) {\n\treturn val != null;\n}\n\nexport function isPlainObj(val) {\n\treturn val != null && val.constructor === Object;\t\t//  && typeof val === \"object\"\n}\n\nexport function insertArr(targ, arr, pos, rem) {\n\ttarg.splice.apply(targ, [pos, rem].concat(arr));\n}\n\nexport function isVal(val) {\n\tvar t = typeof val;\n\treturn t === \"string\" || t === \"number\";\n}\n\nexport function isFunc(val) {\n\treturn typeof val === \"function\";\n}\n\nexport function isProm(val) {\n\treturn typeof val === \"object\" && isFunc(val.then);\n}\n\nexport function isElem(val) {\n\treturn ENV_DOM && val instanceof HTMLElement;\n}\n\nexport function assignObj(targ) {\n\tvar args = arguments;\n\n\tfor (var i = 1; i < args.length; i++)\n\t\tfor (var k in args[i])\n\t\t\ttarg[k] = args[i][k];\n\n\treturn targ;\n}\n\n// export const defProp = Object.defineProperty;\n\nexport function deepSet(targ, path, val) {\n\tvar seg;\n\n\twhile (seg = path.shift()) {\n\t\tif (path.length === 0)\n\t\t\ttarg[seg] = val;\n\t\telse\n\t\t\ttarg[seg] = targ = targ[seg] || {};\n\t}\n}\n\n/*\nexport function deepUnset(targ, path) {\n\tvar seg;\n\n\twhile (seg = path.shift()) {\n\t\tif (path.length === 0)\n\t\t\ttarg[seg] = val;\n\t\telse\n\t\t\ttarg[seg] = targ = targ[seg] || {};\n\t}\n}\n*/\n\nexport function sliceArgs(args, offs) {\n\tvar arr = [];\n\tfor (var i = offs; i < args.length; i++)\n\t\tarr.push(args[i]);\n\treturn arr;\n}\n\nexport function cmpObj(a, b) {\n\tfor (var i in a)\n\t\tif (a[i] !== b[i])\n\t\t\treturn false;\n\n\treturn true;\n}\n\nexport function cmpArr(a, b) {\n\tconst alen = a.length;\n\n\tif (b.length !== alen)\n\t\treturn false;\n\n\tfor (var i = 0; i < alen; i++)\n\t\tif (a[i] !== b[i])\n\t\t\treturn false;\n\n\treturn true;\n}\n\n// https://github.com/darsain/raft\n// rAF throttler, aggregates multiple repeated redraw calls within single animframe\nexport function raft(fn) {\n\tif (!rAF)\n\t\treturn fn;\n\n\tvar id, ctx, args;\n\n\tfunction call() {\n\t\tid = 0;\n\t\tfn.apply(ctx, args);\n\t}\n\n\treturn function() {\n\t\tctx = this;\n\t\targs = arguments;\n\t\tif (!id) id = rAF(call);\n\t};\n}\n\nexport function curry(fn, args, ctx) {\n\treturn function() {\n\t\treturn fn.apply(ctx, args);\n\t};\n}\n\nexport function prop(val, cb, ctx, args) {\n\treturn function(newVal, execCb) {\n\t\tif (newVal !== undefined && newVal !== val) {\n\t\t\tval = newVal;\n\t\t\texecCb !== false && isFunc(cb) && cb.apply(ctx, args);\n\t\t}\n\n\t\treturn val;\n\t};\n}\n\n// adapted from https://github.com/Olical/binary-search\nexport function binaryKeySearch(list, item) {\n    var min = 0;\n    var max = list.length - 1;\n    var guess;\n\n\tvar bitwise = (max <= 2147483647) ? true : false;\n\tif (bitwise) {\n\t\twhile (min <= max) {\n\t\t\tguess = (min + max) >> 1;\n\t\t\tif (list[guess].key === item) { return guess; }\n\t\t\telse {\n\t\t\t\tif (list[guess].key < item) { min = guess + 1; }\n\t\t\t\telse { max = guess - 1; }\n\t\t\t}\n\t\t}\n\t} else {\n\t\twhile (min <= max) {\n\t\t\tguess = Math.floor((min + max) / 2);\n\t\t\tif (list[guess].key === item) { return guess; }\n\t\t\telse {\n\t\t\t\tif (list[guess].key < item) { min = guess + 1; }\n\t\t\t\telse { max = guess - 1; }\n\t\t\t}\n\t\t}\n\t}\n\n    return -1;\n}","import { emptyObj } from '../utils';\n\nexport function isEvProp(name) {\n\treturn name[0] === \"o\" && name[1] === \"n\";\n}\n\nexport function isSplProp(name) {\n\treturn name[0] === \"_\";\n}\n\nexport function isStyleProp(name) {\n\treturn name === \"style\";\n}\n\nexport function repaint(node) {\n\tnode && node.el && node.el.offsetHeight;\n}\n\n// tests interactive props where real val should be compared\nexport function isDynProp(tag, attr) {\n//\tswitch (tag) {\n//\t\tcase \"input\":\n//\t\tcase \"textarea\":\n//\t\tcase \"select\":\n//\t\tcase \"option\":\n\t\t\tswitch (attr) {\n\t\t\t\tcase \"value\":\n\t\t\t\tcase \"checked\":\n\t\t\t\tcase \"selected\":\n//\t\t\t\tcase \"selectedIndex\":\n\t\t\t\t\treturn true;\n\t\t\t}\n//\t}\n\n\treturn false;\n}\n\nexport function getVm(n) {\n\tn = n || emptyObj;\n\twhile (n.vm == null && n.parent)\n\t\tn = n.parent;\n\treturn n.vm;\n}","import { autoPx } from './autoPx';\nimport { cssTag } from './cssTag';\nimport { isStream, hookStream } from './streamCfg';\nimport { noop } from '../../utils';\n\n// stubs for optional addons that still exist in code so need lightweight impls to run\nfunction isStreamStub() { return false; };\nfunction autoPxStub(name, val) { return val; };\nconst hookStreamStub = noop;\n\nconst tagObj = {};\nfunction cssTagStub(tag) { tagObj.tag = tag; return tagObj; };\n\nexport { autoPxStub as autoPx }\nexport { cssTagStub as cssTag }\nexport { isStreamStub as isStream }\nexport { hookStreamStub as hookStream }","import { isVal, emptyObj } from '../utils';\nimport { getVm } from './utils';\nimport { autoPx, isStream, hookStream } from './addons/stubs';\n\n// assumes if styles exist both are objects or both are strings\nexport function patchStyle(n, o) {\n\tvar ns =     (n.attrs || emptyObj).style;\n\tvar os = o ? (o.attrs || emptyObj).style : null;\n\n\t// replace or remove in full\n\tif (ns == null || isVal(ns))\n\t\tn.el.style.cssText = ns;\n\telse {\n\t\tfor (var nn in ns) {\n\t\t\tvar nv = ns[nn];\n\n\t\t\tif (isStream(nv))\n\t\t\t\tnv = hookStream(nv, getVm(n));\n\n\t\t\tif (os == null || nv != null && nv !== os[nn])\n\t\t\t\tn.el.style[nn] = autoPx(nn, nv);\n\t\t}\n\n\t\t// clean old\n\t\tif (os) {\n\t\t\tfor (var on in os) {\n\t\t\t\tif (ns[on] == null)\n\t\t\t\t\tn.el.style[on] = \"\";\n\t\t\t}\n\t\t}\n\t}\n}","import { isArr } from '../utils';\nimport { repaint } from './utils';\n\nexport const didQueue = [];\n\nfunction fireHook(did, fn, o, n, immediate) {\n\tif (did) {\t// did*\n\t\t//\tconsole.log(name + \" should queue till repaint\", o, n);\n\t\timmediate ? repaint(o.parent) && fn(o, n) : didQueue.push([fn, o, n]);\n\t}\n\telse {\t\t// will*\n\t\t//\tconsole.log(name + \" may delay by promise\", o, n);\n\t\treturn fn(o, n);\t\t// or pass  done() resolver\n\t}\n}\n\nexport function fireHooks(name, o, n, immediate) {\n\tvar hook = o.hooks[name];\n\n\tif (hook) {\n\t\tvar did = name[0] === \"d\" && name[1] === \"i\" && name[2] === \"d\";\n\n\t\tif (isArr(hook)) {\n\t\t\t// TODO: promise.all() this?\n\t\t\treturn hook.map(function(hook2) {\n\t\t\t\treturn fireHook(did, hook2, o, n);\n\t\t\t});\n\t\t}\n\t\telse\n\t\t\treturn fireHook(did, hook, o, n, immediate);\n\t}\n}","export function VNode() {}\n\nexport const VNodeProto = VNode.prototype = {\n\tconstructor: VNode,\n\n\ttype:\tnull,\n\n\tvm:\t\tnull,\n\n\t// all this stuff can just live in attrs (as defined) just have getters here for it\n\tkey:\tnull,\n\tref:\tnull,\n\tdata:\tnull,\n\thooks:\tnull,\n\traw:\tfalse,\n\tns:\t\tnull,\n\n\tel:\t\tnull,\n\n\ttag:\tnull,\n\tattrs:\tnull,\n\tbody:\tnull,\n\n\tflags:\t0,\n\n\t_class:\tnull,\n\n\tidx:\tnull,\n\tparent:\tnull,\n\n\t/*\n\t// break out into optional fluent module\n\tkey:\tfunction(val) { this.key\t= val; return this; },\n\tref:\tfunction(val) { this.ref\t= val; return this; },\t\t// deep refs\n\tdata:\tfunction(val) { this.data\t= val; return this; },\n\thooks:\tfunction(val) { this.hooks\t= val; return this; },\t\t// h(\"div\").hooks()\n\thtml:\tfunction(val) { this.html\t= true; return this.body(val); },\n\n\tbody:\tfunction(val) { this.body\t= val; return this; },\n\t*/\n};","import { ELEMENT } from './VTYPES';\nimport { VNode } from './VNode';\nimport { cssTag } from './addons/stubs';\nimport { isSet, isPlainObj } from '../utils';\nimport { devNotify } from \"./addons/devmode\";\n\n// (de)optimization flags\n\n// prevents inserting/removing/reordering of children\nexport const FIXED_BODY = 1;\n// forces slow bottom-up removeChild to fire deep willRemove/willUnmount hooks,\nexport const DEEP_REMOVE = 2;\n// enables fast keyed lookup of children via binary search, expects homogeneous keyed body\nexport const KEYED_LIST = 4;\n\nexport function initElementNode(tag, attrs, body, flags) {\n\tlet node = new VNode;\n\n\tnode.type = ELEMENT;\n\n\tif (isSet(flags))\n\t\tnode.flags = flags;\n\n\tnode.attrs = attrs;\n\n\tvar parsed = cssTag(tag);\n\n\tnode.tag = parsed.tag;\n\n\t// meh, weak assertion, will fail for id=0, etc.\n\tif (parsed.id || parsed.class || parsed.attrs) {\n\t\tvar p = node.attrs || {};\n\n\t\tif (parsed.id && !isSet(p.id))\n\t\t\tp.id = parsed.id;\n\n\t\tif (parsed.class) {\n\t\t\tnode._class = parsed.class;\t\t// static class\n\t\t\tp.class = parsed.class + (isSet(p.class) ? (\" \" + p.class) : \"\");\n\t\t}\n\t\tif (parsed.attrs) {\n\t\t\tfor (var key in parsed.attrs)\n\t\t\t\tif (!isSet(p[key]))\n\t\t\t\t\tp[key] = parsed.attrs[key];\n\t\t}\n\n//\t\tif (node.attrs !== p)\n\t\t\tnode.attrs = p;\n\t}\n\n\tvar mergedAttrs = node.attrs;\n\n\tif (isSet(mergedAttrs)) {\n\t\tif (isSet(mergedAttrs._key))\n\t\t\tnode.key = mergedAttrs._key;\n\n\t\tif (isSet(mergedAttrs._ref))\n\t\t\tnode.ref = mergedAttrs._ref;\n\n\t\tif (isSet(mergedAttrs._hooks))\n\t\t\tnode.hooks = mergedAttrs._hooks;\n\n\t\tif (isSet(mergedAttrs._raw))\n\t\t\tnode.raw = mergedAttrs._raw;\n\n\t\tif (isSet(mergedAttrs._data))\n\t\t\tnode.data = mergedAttrs._data;\n\n\t\tif (isSet(mergedAttrs._flags))\n\t\t\tnode.flags = mergedAttrs._flags;\n\n\t\tif (!isSet(node.key)) {\n\t\t\tif (isSet(node.ref))\n\t\t\t\tnode.key = node.ref;\n\t\t\telse if (isSet(mergedAttrs.id))\n\t\t\t\tnode.key = mergedAttrs.id;\n\t\t\telse if (isSet(mergedAttrs.name))\n\t\t\t\tnode.key = mergedAttrs.name;\n\t\t}\n\t}\n\n\tif (body != null)\n\t\tnode.body = body;\n\n\tif (_DEVMODE) {\n\t\tif (node.tag === \"svg\") {\n\t\t\tsetTimeout(function() {\n\t\t\t\tnode.ns == null && devNotify(\"SVG_WRONG_FACTORY\", [node]);\n\t\t\t}, 16);\n\t\t}\n\t\telse if (node.tag === \"input\" && node.key == null)\n\t\t\tdevNotify(\"UNKEYED_INPUT\", [node]);\n\t}\n\n\treturn node;\n}","import { ENV_DOM, isArr, isProm, curry } from '../utils';\nimport { fireHooks } from './hooks';\nimport { FIXED_BODY, DEEP_REMOVE } from './initElementNode';\n\nconst doc = ENV_DOM ? document : null;\n\nexport function closestVNode(el) {\n\twhile (el._node == null)\n\t\tel = el.parentNode;\n\treturn el._node;\n}\n\nexport function createElement(tag, ns) {\n\tif (ns != null)\n\t\treturn doc.createElementNS(ns, tag);\n\treturn doc.createElement(tag);\n}\n\nexport function createTextNode(body) {\n\treturn doc.createTextNode(body);\n}\n\nexport function createComment(body) {\n\treturn doc.createComment(body);\n}\n\n// ? removes if !recycled\nexport function nextSib(sib) {\n\treturn sib.nextSibling;\n}\n\n// ? removes if !recycled\nexport function prevSib(sib) {\n\treturn sib.previousSibling;\n}\n\n// TODO: this should collect all deep proms from all hooks and return Promise.all()\nfunction deepNotifyRemove(node) {\n\tvar hooks = node.hooks, vm = node.vm;\n\n\tvm && vm.hooks && fireHooks(\"willUnmount\", vm);\n\n\tvar res = hooks && fireHooks(\"willRemove\", node);\n\n\tif ((node.flags & DEEP_REMOVE) === DEEP_REMOVE && isArr(node.body)) {\n\t\tfor (var i = 0; i < node.body.length; i++)\n\t\t\tdeepNotifyRemove(node.body[i]);\n\t}\n\n\treturn res;\n}\n\nfunction _removeChild(parEl, el, immediate) {\n\tvar node = el._node, hooks = node.hooks, vm = node.vm;\n\n\tif ((node.flags & DEEP_REMOVE) === DEEP_REMOVE && isArr(node.body)) {\n\t//\tvar parEl = node.el;\n\t\tfor (var i = 0; i < node.body.length; i++)\n\t\t\t_removeChild(el, node.body[i].el);\n\t}\n\n\tparEl.removeChild(el);\n\n\thooks && fireHooks(\"didRemove\", node, null, immediate);\n\n\tvm && vm.hooks && fireHooks(\"didUnmount\", vm, null, immediate);\n}\n\n// todo: should delay parent unmount() by returning res prom?\nexport function removeChild(parEl, el) {\n\tvar node = el._node, hooks = node.hooks;\n\n\tvar res = deepNotifyRemove(node);\n\n\tif (res != null && isProm(res))\n\t\tres.then(curry(_removeChild, [parEl, el, true]));\n\telse\n\t\t_removeChild(parEl, el);\n}\n\nexport function clearChildren(parent) {\n\tvar parEl = parent.el;\n\n\tif ((parent.flags & DEEP_REMOVE) === 0)\n\t\tparEl.textContent = null;\n\telse {\n\t\twhile (parEl.firstChild)\n\t\t\tremoveChild(parEl, parEl.firstChild);\n\t}\n}\n\n// todo: hooks\nexport function insertBefore(parEl, el, refEl) {\n\tvar node = el._node, hooks = node.hooks, inDom = el.parentNode != null;\n\n\t// el === refEl is asserted as a no-op insert called to fire hooks\n\tvar vm = (el === refEl || !inDom) && node.vm;\n\n\tvm && vm.hooks && fireHooks(\"willMount\", vm);\n\n\thooks && fireHooks(inDom ? \"willReinsert\" : \"willInsert\", node);\n\tparEl.insertBefore(el, refEl);\n\thooks && fireHooks(inDom ? \"didReinsert\" : \"didInsert\", node);\n\n\tvm && vm.hooks && fireHooks(\"didMount\", vm);\n}\n\nexport function insertAfter(parEl, el, refEl) {\n\tinsertBefore(parEl, el, refEl ? nextSib(refEl) : null);\n}","import { noop, assignObj } from '../utils';\n\nexport const globalCfg = {\n\tonevent: noop,\n};\n\nexport function config(newCfg) {\n\tassignObj(globalCfg, newCfg);\n}","import { isArr, isFunc, cmpArr } from '../utils';\nimport { closestVNode } from './dom';\nimport { getVm } from './utils';\nimport { globalCfg } from './config';\nimport { devNotify } from \"./addons/devmode\";\n\nfunction bindEv(el, type, fn) {\n//\tDEBUG && console.log(\"addEventListener\");\n\tel[type] = fn;\n}\n\nfunction handle(e, fn, args) {\n\tvar node = closestVNode(e.target);\n\tvar vm = getVm(node);\n\tvar out = fn.apply(null, args.concat(e, node, vm));\n\tglobalCfg.onevent.apply(null, [e, node, vm].concat(args));\n\n\tif (out === false) {\n\t\te.preventDefault();\n\t\te.stopPropagation();\n\t}\n}\n\nfunction wrapHandler(fn, args) {\n//\tconsole.log(\"wrapHandler\");\n\n\treturn function wrap(e) {\n\t\thandle(e, fn, args);\n\t};\n}\n\n// delagated handlers {\".moo\": [fn, a, b]}, {\".moo\": fn}\nfunction wrapHandlers(hash) {\n//\tconsole.log(\"wrapHandlers\");\n\n\treturn function wrap(e) {\n\t\tfor (var sel in hash) {\n\t\t\tif (e.target.matches(sel)) {\n\t\t\t\tvar hnd = hash[sel];\n\t\t\t\tvar isarr = isArr(hnd);\n\t\t\t\tvar fn = isarr ? hnd[0] : hnd;\n\t\t\t\tvar args = isarr ? hnd.slice(1) : [];\n\n\t\t\t\thandle(e, fn, args);\n\t\t\t}\n\t\t}\n\t}\n}\n\n// could merge with on*\n\nexport function patchEvent(node, name, nval, oval) {\n\tif (nval === oval)\n\t\treturn;\n\n\tif (_DEVMODE) {\n\t\tif (isFunc(nval) && isFunc(oval) && oval.name == nval.name)\n\t\t\tdevNotify(\"INLINE_HANDLER\", [node, oval, nval]);\n\t}\n\n\tvar el = node.el;\n\n\t// param'd eg onclick: [myFn, 1, 2, 3...]\n\tif (isArr(nval)) {\n\t\tif (_DEVMODE) {\n\t\t\tif (oval != null && !isArr(oval))\n\t\t\t\tdevNotify(\"MISMATCHED_HANDLER\", [node, oval, nval]);\n\t\t}\n\t\tvar diff = oval == null || !cmpArr(nval, oval);\n\t\tdiff && bindEv(el, name, wrapHandler(nval[0], nval.slice(1)));\n\t}\n\t// basic onclick: myFn (or extracted)\n\telse if (isFunc(nval) && nval !== oval) {\n\t\tif (_DEVMODE) {\n\t\t\tif (oval != null && !isFunc(oval))\n\t\t\t\tdevNotify(\"MISMATCHED_HANDLER\", [node, oval, nval]);\n\t\t}\n\t\tbindEv(el, name, wrapHandler(nval, []));\n\t}\n\t// delegated onclick: {\".sel\": myFn} & onclick: {\".sel\": [myFn, 1, 2, 3]}\n\telse\t\t// isPlainObj, TODO:, diff with old/clean\n\t\tbindEv(el, name, wrapHandlers(nval));\n}","import { isStyleProp, isSplProp, isEvProp, isDynProp, getVm } from './utils';\nimport { isFunc, emptyObj } from '../utils';\nimport { patchStyle } from './patchStyle';\nimport { patchEvent } from './patchEvent';\nimport { isStream, hookStream } from './addons/stubs';\nimport { devNotify } from \"./addons/devmode\";\n\nexport function remAttr(node, name, asProp) {\n\tif (asProp)\n\t\tnode.el[name] = \"\";\n\telse\n\t\tnode.el.removeAttribute(name);\n}\n\n// setAttr\n// diff, \".\", \"on*\", bool vals, skip _*, value/checked/selected selectedIndex\nexport function setAttr(node, name, val, asProp) {\n\tvar el = node.el;\n\n\tif (val == null)\n\t\tremAttr(node, name);\t\t//, asProp?  // will also removeAttr of style: null\n\telse if (node.ns != null)\n\t\tel.setAttribute(name, val);\n\telse if (name === \"class\")\n\t\tel.className = val;\n\telse if (name === \"id\" || typeof val === \"boolean\" || asProp)\n\t\tel[name] = val;\n\telse if (name[0] === \".\")\n\t\tel[name.substr(1)] = val;\n\telse\n\t\tel.setAttribute(name, val);\n}\n\nexport function patchAttrs(vnode, donor) {\n\tconst nattrs = vnode.attrs || emptyObj;\n\tconst oattrs = donor.attrs || emptyObj;\n\n\tif (nattrs === oattrs) {\n\t\tif (_DEVMODE)\n\t\t\tdevNotify(\"REUSED_ATTRS\", [vnode]);\n\t}\n\telse {\n\t\tfor (var key in nattrs) {\n\t\t\tvar nval = nattrs[key];\n\t\t\tvar isDyn = isDynProp(vnode.tag, key);\n\t\t\tvar oval = isDyn ? vnode.el[key] : oattrs[key];\n\n\t\t\tif (isStream(nval))\n\t\t\t\tnattrs[key] = nval = hookStream(nval, getVm(vnode));\n\n\t\t\tif (nval === oval) {}\n\t\t\telse if (isStyleProp(key))\n\t\t\t\tpatchStyle(vnode, donor);\n\t\t\telse if (isSplProp(key)) {}\n\t\t\telse if (isEvProp(key))\n\t\t\t\tpatchEvent(vnode, key, nval, oval);\n\t\t\telse\n\t\t\t\tsetAttr(vnode, key, nval, isDyn);\n\t\t}\n\n\t\t// TODO: handle key[0] === \".\"\n\t\t// should bench style.cssText = \"\" vs removeAttribute(\"style\")\n\t\tfor (var key in oattrs) {\n\t\t\t!(key in nattrs) &&\n\t\t\t!isSplProp(key) &&\n\t\t\tremAttr(vnode, key, isDynProp(vnode.tag, key) || isEvProp(key));\n\t\t}\n\t}\n}","import { ELEMENT, TEXT, COMMENT, VVIEW, VMODEL } from './VTYPES';\nimport { ViewModel } from './ViewModel';\n\nexport function createView(view, model, key, opts) {\n\tif (view.type === VVIEW) {\n\t\tmodel\t= view.model;\n\t\tkey\t\t= view.key;\n\t\topts\t= view.opts;\n\t\tview\t= view.view;\n\t}\n\telse if (view.prototype._isClass)\n\t\treturn new view(model, key, opts);\n\n\treturn new ViewModel(view, model, key, opts);\n}","import { ELEMENT, TEXT, COMMENT, VVIEW, VMODEL } from './VTYPES';\nimport { isArr } from '../utils';\nimport { isStyleProp, isSplProp, isEvProp, isDynProp, getVm } from './utils';\nimport { isStream, hookStream } from './addons/stubs';\nimport { setAttr } from './patchAttrs';\nimport { patchStyle } from './patchStyle';\nimport { patchEvent } from './patchEvent';\nimport { createView } from './createView';\n//import { XML_NS, XLINK_NS } from './defineSvgElement';\nimport { createElement, createTextNode, createComment, insertBefore } from './dom';\n\n// TODO: DRY this out. reusing normal patchAttrs here negatively affects V8's JIT\nfunction patchAttrs2(vnode) {\n\tvar nattrs = vnode.attrs;\n\n\tfor (var key in nattrs) {\n\t\tvar nval = nattrs[key];\n\t\tvar isDyn = isDynProp(vnode.tag, key);\n\n\t\tif (isStream(nval))\n\t\t\tnattrs[key] = nval = hookStream(nval, getVm(vnode));\n\n\t\tif (isStyleProp(key))\n\t\t\tpatchStyle(vnode);\n\t\telse if (isSplProp(key)) {}\n\t\telse if (isEvProp(key))\n\t\t\tpatchEvent(vnode, key, nval);\n\t\telse if (nval != null)\n\t\t\tsetAttr(vnode, key, nval, isDyn);\n\t}\n}\n\nexport function hydrateBody(vnode) {\n\tfor (var i = 0; i < vnode.body.length; i++) {\n\t\tvar vnode2 = vnode.body[i];\n\t\tvar type2 = vnode2.type;\n\n\t\t// ELEMENT,TEXT,COMMENT\n\t\tif (type2 <= COMMENT)\n\t\t\tinsertBefore(vnode.el, hydrate(vnode2));\t\t// vnode.el.appendChild(hydrate(vnode2))\n\t\telse if (type2 === VVIEW) {\n\t\t\tvar vm = createView(vnode2.view, vnode2.model, vnode2.key, vnode2.opts)._redraw(vnode, i, false);\t\t// todo: handle new model updates\n\t\t\ttype2 = vm.node.type;\n\t\t\tinsertBefore(vnode.el, hydrate(vm.node));\n\t\t}\n\t\telse if (type2 === VMODEL) {\n\t\t\tvar vm = vnode2.vm;\n\t\t\tvm._redraw(vnode, i);\t\t\t\t\t// , false\n\t\t\ttype2 = vm.node.type;\n\t\t\tinsertBefore(vnode.el, vm.node.el);\t\t// , hydrate(vm.node)\n\t\t}\n\t}\n}\n\n//  TODO: DRY this out. reusing normal patch here negatively affects V8's JIT\nexport function hydrate(vnode, withEl) {\n\tif (vnode.el == null) {\n\t\tif (vnode.type === ELEMENT) {\n\t\t\tvnode.el = withEl || createElement(vnode.tag, vnode.ns);\n\n\t\t//\tif (vnode.tag === \"svg\")\n\t\t//\t\tvnode.el.setAttributeNS(XML_NS, 'xmlns:xlink', XLINK_NS);\n\n\t\t\tif (vnode.attrs != null)\n\t\t\t\tpatchAttrs2(vnode);\n\n\t\t\tif (isArr(vnode.body))\n\t\t\t\thydrateBody(vnode);\n\t\t\telse if (vnode.body != null && vnode.body !== \"\") {\n\t\t\t\tif (vnode.raw)\n\t\t\t\t\tvnode.el.innerHTML = vnode.body;\n\t\t\t\telse\n\t\t\t\t\tvnode.el.textContent = vnode.body;\n\t\t\t}\n\t\t}\n\t\telse if (vnode.type === TEXT)\n\t\t\tvnode.el = withEl || createTextNode(vnode.body);\n\t\telse if (vnode.type === COMMENT)\n\t\t\tvnode.el = withEl || createComment(vnode.body);\n\t}\n\n\tvnode.el._node = vnode;\n\n\treturn vnode.el;\n}","import { emptyObj } from '../utils';\nimport { hydrate } from './hydrate';\nimport { prevSib, nextSib, insertBefore, insertAfter, removeChild } from './dom';\nimport { devNotify } from \"./addons/devmode\";\n\nfunction nextNode(node, body) {\n\treturn body[node.idx + 1];\n}\n\nfunction prevNode(node, body) {\n\treturn body[node.idx - 1];\n}\n\nfunction parentNode(node) {\n\treturn node.parent;\n}\n\nfunction cmpElNodeIdx(a, b) {\n\treturn a._node.idx - b._node.idx;\n}\n\nfunction tmpEdges(fn, parEl, lftSib, rgtSib) {\n\t// get outer immute edges\n\tvar lftLft = prevSib(lftSib);\n\tvar rgtRgt = nextSib(rgtSib);\n\n\tfn(lftLft, rgtRgt);\n\n\treturn {\n\t\tlftSib: lftLft ? nextSib(lftLft) : parEl.firstChild,\n\t\trgtSib: rgtRgt ? prevSib(rgtRgt) : parEl.lastChild,\n\t};\n}\n\nfunction headTailTry(parEl, lftSib, lftNode, rgtSib, rgtNode) {\n\tvar areAdjacent\t= rgtNode.idx === lftNode.idx + 1;\n\tvar headToTail = areAdjacent ? false : lftSib._node === rgtNode;\n\tvar tailToHead = areAdjacent ? true  : rgtSib._node === lftNode;\n\n\tif (headToTail || tailToHead) {\n\t\treturn tmpEdges(function(lftLft, rgtRgt) {\n\t\t\tif (tailToHead)\n\t\t\t\tinsertBefore(parEl, rgtSib, lftSib);\n\n\t\t\tif (headToTail)\n\t\t\t\tinsertBefore(parEl, lftSib, rgtRgt);\n\t\t}, parEl, lftSib, rgtSib);\n\t}\n\n\treturn null;\n}\n\n// init vm,\n\n// selection sort of DOM (cause move cost >> cmp cost)\n// todo: skip removed\nfunction sortDOM(parEl, lftSib, rgtSib, cmpFn) {\n//\tDEBUG && console.log(\"selection sort!\");\n\n\treturn tmpEdges(function(lftLft, rgtRgt) {\n\t\tvar min;\n\n\t\tfor (var i = lftSib; i !== rgtRgt; i = nextSib(i)) {\n\t\t\tlftSib = min = i;\n\n\t\t\tfor (var j = nextSib(i); j !== rgtRgt; j = nextSib(j)) {\n\t\t\t\tif (cmpFn(min, j) > 0)\n\t\t\t\t\tmin = j;\n\t\t\t}\n\n\t\t\tif (min === i)\n\t\t\t\tcontinue;\n\n\t\t\tinsertBefore(parEl, min, lftSib);\n\n\t\t\ti = min;\n\t\t}\n\t}, parEl, lftSib, rgtSib);\n}\n\nfunction cmpElNodeIdx(a, b) {\n\treturn a._node.idx - b._node.idx;\n}\n\nexport function syncChildren(node, donor) {\n\tvar parEl\t\t= node.el,\n\t\tbody\t\t= node.body,\n\t\tobody\t\t= donor.body,\n\t\tlftNode\t\t= body[0],\n\t\trgtNode\t\t= body[body.length - 1],\n\t\tlftSib\t\t= ((obody)[0] || emptyObj).el,\n\t//\tlftEnd\t\t= prevSib(lftSib),\n\t\trgtSib\t\t= (obody[obody.length - 1] || emptyObj).el,\n\t//\trgtEnd\t\t= nextSib(rgtSib),\n\t\tnewSibs,\n\t\ttmpSib,\n\t\tlsNode,\n\t\trsNode;\n\n\tconverge:\n\twhile (1) {\n//\t\tfrom_left:\n\t\twhile (1) {\n\t\t\t// remove any non-recycled sibs whose el.node has the old parent\n\t\t\tif (lftSib) {\n\t\t\t\t// skip dom elements not created by domvm\n\t\t\t\tif ((lsNode = lftSib._node) == null) {\n\t\t\t\t\tif (_DEVMODE)\n\t\t\t\t\t\tdevNotify(\"FOREIGN_ELEMENT\", [lftSib]);\n\n\t\t\t\t\tlftSib = nextSib(lftSib);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (parentNode(lsNode) !== node) {\n\t\t\t\t\ttmpSib = nextSib(lftSib);\n\t\t\t\t\tlsNode.vm != null ? lsNode.vm.unmount(true) : removeChild(parEl, lftSib);\n\t\t\t\t\tlftSib = tmpSib;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (lftNode == null)\t\t// reached end\n\t\t\t\tbreak converge;\n\t\t\telse if (lftNode.el == null) {\n\t\t\t\tinsertBefore(parEl, hydrate(lftNode), lftSib);\t\t// lftNode.vm != null ? lftNode.vm.mount(parEl, false, true, lftSib) :\n\t\t\t\tlftNode = nextNode(lftNode, body);\n\t\t\t}\n\t\t\telse if (lftNode.el === lftSib) {\n\t\t\t\tlftNode = nextNode(lftNode, body);\n\t\t\t\tlftSib = nextSib(lftSib);\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\n//\t\tfrom_right:\n\t\twhile (1) {\n\t\t//\tif (rgtSib === lftEnd)\n\t\t//\t\tbreak converge;\n\n\t\t\tif (rgtSib) {\n\t\t\t\tif ((rsNode = rgtSib._node) == null) {\n\t\t\t\t\tif (_DEVMODE)\n\t\t\t\t\t\tdevNotify(\"FOREIGN_ELEMENT\", [rgtSib]);\n\n\t\t\t\t\trgtSib = prevSib(rgtSib);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (parentNode(rsNode) !== node) {\n\t\t\t\t\ttmpSib = prevSib(rgtSib);\n\t\t\t\t\trsNode.vm != null ? rsNode.vm.unmount(true) : removeChild(parEl, rgtSib);\n\t\t\t\t\trgtSib = tmpSib;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rgtNode === lftNode)\t\t// converged\n\t\t\t\tbreak converge;\n\t\t\telse if (rgtNode.el == null) {\n\t\t\t\tinsertAfter(parEl, hydrate(rgtNode), rgtSib);\t\t// rgtNode.vm != null ? rgtNode.vm.mount(parEl, false, true, nextSib(rgtSib) :\n\t\t\t\trgtNode = prevNode(rgtNode, body);\n\t\t\t}\n\t\t\telse if (rgtNode.el === rgtSib) {\n\t\t\t\trgtNode = prevNode(rgtNode, body);\n\t\t\t\trgtSib = prevSib(rgtSib);\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (newSibs = headTailTry(parEl, lftSib, lftNode, rgtSib, rgtNode)) {\n\t\t\tlftSib = newSibs.lftSib;\n\t\t\trgtSib = newSibs.rgtSib;\n\t\t\tcontinue;\n\t\t}\n\n\t\tnewSibs = sortDOM(parEl, lftSib, rgtSib, cmpElNodeIdx);\n\t\tlftSib = newSibs.lftSib;\n\t\trgtSib = newSibs.rgtSib;\n\t}\n}","import { ELEMENT, TEXT, COMMENT, VVIEW, VMODEL } from './VTYPES';\nimport { isArr, binaryKeySearch } from '../utils';\nimport { hydrateBody } from './hydrate';\nimport { clearChildren } from './dom';\nimport { syncChildren } from './syncChildren';\nimport { fireHooks } from './hooks';\nimport { patchAttrs } from './patchAttrs';\nimport { createView } from './createView';\nimport { FIXED_BODY, DEEP_REMOVE, KEYED_LIST } from './initElementNode';\n\nfunction findDonor(n, obody, fromIdx, toIdx) {\t\t// pre-tested isView?\n\tfor (; fromIdx < obody.length; fromIdx++) {\n\t\tvar o = obody[fromIdx];\n\n\t\tif (n.type === VVIEW && o.vm != null) {\t\t\t// also ignore recycled/moved?\n\t\t\tvar ov = o.vm;\n\n\t\t\t// match by key & viewFn\n\t\t\tif (ov.view === n.view && ov.key === n.key)\n\t\t\t\treturn o;\n\t\t}\n\n\t\tif (o.el._node !== o || n.tag !== o.tag || n.type !== o.type || n.vm !== o.vm)\n\t\t\tcontinue;\n\n\t\t// if n.view\n\n\t\tif (n.key === o.key)\t\t// accounts for matching & both null\n\t\t\treturn o;\n\t\telse {\n\t\t\t//\n\t\t\tif (o.key == null) {\n\t\t\t\treturn o;\n\t\t\t}\n\t\t\t// n.key && o.key, ident?\n\t\t\telse {\n\t\t\t//\tconsole.log(n.key, o.key);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn null;\n}\n\n// list must be a sorted list of vnodes by key\nfunction findListDonor(n, list) {\n\tvar idx = binaryKeySearch(list, n.key);\n\treturn idx > -1 ? list[idx] : null;\n}\n\n// have it handle initial hydrate? !donor?\n// types (and tags if ELEM) are assumed the same, and donor exists\nexport function patch(vnode, donor, isRedrawRoot) {\n\tdonor.hooks && fireHooks(\"willRecycle\", donor, vnode);\n\n\tvar el = vnode.el = donor.el;\n\n\tvar obody = donor.body;\n\tvar nbody = vnode.body;\n\n\tel._node = vnode;\n\n\t// \"\" => \"\"\n\tif (vnode.type === TEXT && nbody !== obody) {\n\t\tel.nodeValue = nbody;\n\t\treturn;\n\t}\n\n\tif (vnode.attrs != null || donor.attrs != null)\n\t\tpatchAttrs(vnode, donor);\n\n\t// patch events\n\n\tvar oldIsArr = isArr(obody);\n\tvar newIsArr = isArr(nbody);\n\n//\tvar nonEqNewBody = nbody != null && nbody !== obody;\n\n\tif (oldIsArr) {\n\t\t// [] => []\n\t\tif (newIsArr) {\n\t\t//\tconsole.log('[] => []', obody, nbody);\n\t\t\t// graft children\n\t\t\tpatchChildren(vnode, donor, isRedrawRoot);\n\t\t}\n\t\t// [] => \"\" | null\n\t\telse if (nbody !== obody) {\n\t\t\t// needs cleanup pass?\n\t\t//\tconsole.log('[] => \"\"', obody, nbody);\n\n\t\t\tif (nbody != null) {\n\t\t\t\tif (vnode.raw)\n\t\t\t\t\tel.innerHTML = nbody;\n\t\t\t\telse\n\t\t\t\t\tel.textContent = nbody;\n\t\t\t}\n\t\t\telse\n\t\t\t\tclearChildren(donor);\n\t\t}\n\t}\n\telse {\n\t\t// \"\" | null => []\n\t\tif (newIsArr) {\n\t\t//\tconsole.log('\"\" => []', obody, nbody);\t// hydrate new here?\n\t\t\tclearChildren(donor);\n\t\t\thydrateBody(vnode);\n\t\t}\n\t\t// \"\" | null => \"\" | null\n\t\telse if (nbody !== obody) {\n\t\t//\tconsole.log('\"\" => \"\"', donor, vnode);\n\n\t\t\tif (vnode.raw)\n\t\t\t\tel.innerHTML = nbody;\n\t\t\telse if (donor.raw)\n\t\t\t\tel.textContent = nbody;\n\t\t\telse if (el.firstChild)\n\t\t\t\tel.firstChild.nodeValue = nbody;\n\t\t\telse\n\t\t\t\tel.textContent = nbody;\n\t\t}\n\t}\n\n\tdonor.hooks && fireHooks(\"didRecycle\", donor, vnode);\n}\n\nfunction sortByKey(a, b) {\n\treturn a.key > b.key ? 1 : a.key < b.key ? -1 : 0;\n}\n\n// [] => []\nfunction patchChildren(vnode, donor, isRedrawRoot) {\n\tvar nbody = vnode.body,\n\t\tnlen = nbody.length,\n\t\tdomSync = donor.type === ELEMENT && (donor.flags & FIXED_BODY) === 0;\n\n\tif (domSync && nlen === 0) {\n\t\tclearChildren(donor);\n\t\treturn;\n\t}\n\n\tvar isList = (donor.flags & KEYED_LIST) === KEYED_LIST;\n\n\tif (isList) {\n\t\tvar list = donor.body.slice();\n\t\tlist.sort(sortByKey);\n\t\tvar find = findListDonor;\n\t}\n\telse {\n\t\tvar list = donor.body;\n\t\tvar find = findDonor;\n\t}\n\n\tvar donor2,\n\t\tfromIdx = 0;\t\t\t\t// first unrecycled node (search head)\n\n\tfor (var i = 0; i < nlen; i++) {\n\t\tvar node2 = nbody[i];\n\t\tvar type2 = node2.type;\n\n\t\t// ELEMENT,TEXT,COMMENT\n\t\tif (type2 <= COMMENT) {\n\t\t\tif (donor2 = find(node2, list, fromIdx))\n\t\t\t\tpatch(node2, donor2);\n\t\t}\n\t\telse if (type2 === VVIEW) {\n\t\t\tif (donor2 = find(node2, list, fromIdx))\t\t// update/moveTo\n\t\t\t\tvar vm = donor2.vm._update(node2.model, vnode, i);\t\t// withDOM\n\t\t\telse\n\t\t\t\tvar vm = createView(node2.view, node2.model, node2.key, node2.opts)._redraw(vnode, i, false);\t// createView, no dom (will be handled by sync below)\n\n\t\t\ttype2 = vm.node.type;\n\t\t}\n\t\telse if (type2 === VMODEL) {\n\t\t\tvar vm = node2.vm._update(node2.model, vnode, i);\n\t\t\ttype2 = vm.node.type;\n\t\t}\n\n\t\t// to keep search space small, if donation is non-contig, move node fwd?\n\t\t// re-establish contigindex\n\t\tif (!isList && donor2 != null && donor2.idx === fromIdx)\n\t\t\tfromIdx++;\n\t}\n\n\n\tdomSync && syncChildren(vnode, donor);\n}","import { TEXT } from './VTYPES';\nimport { VNode } from './VNode';\n\nexport function defineText(body) {\n\tlet node = new VNode;\n\tnode.type = TEXT;\n\tnode.body = body;\n\treturn node;\n}","import { TEXT, VVIEW, VMODEL } from './VTYPES';\nimport { defineText } from './defineText';\nimport { isVal, isArr, isFunc, insertArr, deepSet } from '../utils';\nimport { getVm } from './utils';\nimport { isStream, hookStream } from './addons/stubs';\nimport { DEEP_REMOVE } from './initElementNode';\n\nfunction setRef(vm, name, node) {\n\tvar path = [\"refs\"].concat(name.split(\".\"));\n\tdeepSet(vm, path, node);\n}\n\nfunction setDeepRemove(node) {\n\twhile (node = node.parent)\n\t\tnode.flags |= DEEP_REMOVE;\n}\n\n// vnew, vold\nexport function preProc(vnew, parent, idx, ownVm) {\n\tif (vnew.type === VMODEL || vnew.type === VVIEW)\n\t\treturn;\n\n\tvnew.parent = parent;\n\tvnew.idx = idx;\n\tvnew.vm = ownVm;\n\n\tif (vnew.ref != null)\n\t\tsetRef(getVm(vnew), vnew.ref, vnew);\n\n\tif (vnew.hooks && vnew.hooks.willRemove || ownVm && ownVm.hooks && ownVm.hooks.willUnmount)\n\t\tsetDeepRemove(vnew);\n\n\tif (isArr(vnew.body))\n\t\tpreProcBody(vnew);\n\telse if (isStream(vnew.body))\n\t\tvnew.body = hookStream(vnew.body, getVm(vnew));\n}\n\nexport function preProcBody(vnew) {\n\tvar body = vnew.body;\n\n\tfor (var i = 0; i < body.length; i++) {\n\t\tvar node2 = body[i];\n\n\t\t// remove false/null/undefined\n\t\tif (node2 === false || node2 == null)\n\t\t\tbody.splice(i--, 1);\n\t\t// flatten arrays\n\t\telse if (isArr(node2))\n\t\t\tinsertArr(body, node2, i--, 1);\n\t\telse {\n\t\t\tif (node2.type == null)\n\t\t\t\tbody[i] = node2 = defineText(\"\"+node2);\n\n\t\t\tif (node2.type === TEXT) {\n\t\t\t\t// remove empty text nodes\n\t\t\t\tif (node2.body == null || node2.body === \"\")\n\t\t\t\t\tbody.splice(i--, 1);\n\t\t\t\t// merge with previous text node\n\t\t\t\telse if (i > 0 && body[i-1].type === TEXT) {\n\t\t\t\t\tbody[i-1].body += node2.body;\n\t\t\t\t\tbody.splice(i--, 1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tpreProc(node2, vnew, i, null);\n\t\t\t}\n\t\t\telse\n\t\t\t\tpreProc(node2, vnew, i, null);\n\t\t}\n\t}\n}","import { patch } from \"./patch\";\nimport { hydrate } from \"./hydrate\";\nimport { preProc } from \"./preProc\";\nimport { isArr, isPlainObj, isFunc, isProm, cmpArr, cmpObj, assignObj, curry, raft } from \"../utils\";\nimport { repaint, getVm } from \"./utils\";\nimport { insertBefore, removeChild, nextSib, clearChildren } from \"./dom\";\nimport { didQueue, fireHooks } from \"./hooks\";\nimport { devNotify } from \"./addons/devmode\";\n\nexport function ViewModel(view, model, key, opts) {\t\t\t// parent, idx, parentVm\n\tvar vm = this;\n\n\tvm.view = view;\n\tvm.model = model;\n\tvm.key = key == null ? model : key;\n\n\tif (_DEVMODE) {\n\t\tif (model != null && model === key)\n\t\t\tdevNotify(\"AUTOKEYED_VIEW\", [vm, model]);\n\t}\n\n\tif (!view.prototype._isClass) {\n\t\tvar out = view.call(vm, vm, model, key, opts);\n\n\t\tif (isFunc(out))\n\t\t\tvm.render = out;\n\t\telse {\n\t\t\tif (out.diff) {\n\t\t\t\tvm.diff(out.diff);\n\t\t\t\tdelete out.diff;\n\t\t\t}\n\n\t\t\tassignObj(vm, out);\n\t\t}\n\t}\n\telse {\n\t//\thandle .diff re-definiton\n\t\tvar vdiff = vm.diff;\n\n\t\tif (vdiff != null && vdiff !== ViewModelProto.diff) {\n\t\t\tvm.diff = ViewModelProto.diff.bind(vm);\n\t\t\tvm.diff(vdiff);\n\t\t}\n\t}\n\n\t// remove this?\n\tif (opts) {\n\t\tvm.opts = opts;\n\n\t\tif (opts.hooks)\n\t\t\tvm.hook(opts.hooks);\n\t\tif (opts.diff)\n\t\t\tvm.diff(opts.diff);\n\t}\n\n\t// these must be created here since debounced per view\n\tvm._redrawAsync = raft(_ => vm._redraw());\n\tvm._updateAsync = raft(newModel => vm._update(newModel));\n\n\tvar hooks = vm.hooks;\n\n\tif (hooks && hooks.didInit)\n\t\thooks.didInit.call(vm, vm, model, key, opts);\n\n//\tthis.update(model, parent, idx, parentVm, false);\n\n\t// proc opts, evctx, watch\n\n//\tthis.update = function(model, withRedraw, parent, idx, parentVm) {};\n}\n\nexport const ViewModelProto = ViewModel.prototype = {\n\tconstructor: ViewModel,\n\n\t_isClass: false,\n\n\t// view + key serve as the vm's unique identity\n\tview: null,\n\tkey: null,\n\tmodel: null,\n\topts: null,\n\tnode: null,\n//\tdiff: null,\n//\tdiffLast: null,\t// prior array of diff values\n\thooks: null,\n\trender: null,\n\n//\t_setRef: function() {},\n\n\t// as plugins?\n\tparent: function() {\n\t\treturn getVm(this.node.parent);\n\t},\n\n\troot: function() {\n\t\tvar p = this.node;\n\n\t\twhile (p.parent)\n\t\t\tp = p.parent;\n\n\t\treturn p.vm;\n\t},\n\n\tapi: null,\n\trefs: null,\n\tmount: mount,\n\tunmount: unmount,\n\tredraw: function(sync) {\n\t\tvar vm = this;\n\t\tsync ? vm._redraw() : vm._redrawAsync();\n\t\treturn vm;\n\t},\n\tupdate: function(newModel, sync) {\n\t\tvar vm = this;\n\t\tsync ? vm._update(newModel) : vm._updateAsync(newModel);\n\t\treturn vm;\n\t},\n\n\t_update: updateSync,\n\t_redraw: redrawSync,\t// non-coalesced / synchronous\n\t_redrawAsync: null,\t\t// this is set in constructor per view\n\t_updateAsync: null,\n\n\thook: function(hooks) {\n\t\tthis.hooks = this.hooks || assignObj({}, this.hooks, hooks);\n\t},\n};\n\n\nexport function drainDidHooks(vm) {\n\tif (didQueue.length) {\n\t\trepaint(vm.node);\n\n\t\tvar item;\n\t\twhile (item = didQueue.shift())\n\t\t\titem[0](item[1], item[2]);\n\t}\n}\n\n/*\nfunction isEmptyObj(o) {\n\tfor (var k in o)\n\t\treturn false;\n\treturn true;\n}\n*/\n\nfunction mount(el, isRoot) {\t\t// , asSub, refEl\n\tvar vm = this;\n\n\tif (isRoot) {\n\t\tclearChildren({el: el, flags: 0});\n\n\t\tvm._redraw(null, null, false);\n\n\t\t// if placeholder node doesnt match root tag\n\t\tif (el.nodeName.toLowerCase() !== vm.node.tag) {\n\t\t\thydrate(vm.node);\n\t\t\tinsertBefore(el.parentNode, vm.node.el, el);\n\t\t\tel.parentNode.removeChild(el);\n\t\t}\n\t\telse\n\t\t\tinsertBefore(el.parentNode, hydrate(vm.node, el), el);\n\t}\n\telse {\n\t\tvm._redraw(null, null);\n\n\t\tif (el)\n\t\t\tinsertBefore(el, vm.node.el);\t\t\t// el.appendChild(vm.node.el);\n\t}\n\n\tif (el)\n\t\tdrainDidHooks(vm);\n\n\treturn vm;\n}\n\n// asSub = true means this was called from a sub-routine, so don't drain did* hook queue\n// immediate = true means did* hook will not be queued (usually cause this is a promise resolution)\nfunction unmount(asSub) {\n\tvar vm = this;\n\n\tvar node = vm.node;\n\tvar parEl = node.el.parentNode;\n\n\t// edge bug: this could also be willRemove promise-delayed; should .then() or something to make sure hooks fire in order\n\tremoveChild(parEl, node.el);\n\n\tif (!asSub)\n\t\tdrainDidHooks(vm);\n}\n\n// level, isRoot?\n// newParent, newIdx\n// ancest by ref, by key\nfunction redrawSync(newParent, newIdx, withDOM) {\n\tconst isRedrawRoot = newParent == null;\n\tvar vm = this;\n\tvar isMounted = vm.node && vm.node.el && vm.node.el.parentNode;\n\n\tif (_DEVMODE) {\n\t\t// was mounted (has node and el), but el no longer has parent (unmounted)\n\t\tif (isRedrawRoot && vm.node && vm.node.el && !vm.node.el.parentNode)\n\t\t\tdevNotify(\"UNMOUNTED_REDRAW\", [vm]);\n\t}\n\n\tvar vold = vm.node;\n\n\t// no diff, just re-parent old\n\t// TODO: allow returning vm.node as no-change indicator\n\tif (isMounted && vm._diff != null && vm._diff()) {\n\t\t// will doing this outside of preproc cause de-opt, add shallow opt to preproc?\n\t\tif (vold && newParent) {\n\t\t\tnewParent.body[newIdx] = vold;\n\t\t\tvold.idx = newIdx;\n\t\t\tvold.parent = newParent;\n\t\t}\n\t\treturn vm;\n\t}\n\n\tisMounted && vm.hooks && fireHooks(\"willRedraw\", vm);\n\n\t// todo: test result of willRedraw hooks before clearing refs\n\tvm.refs = null;\n\n\tvar vnew = vm.render.call(vm, vm, vm.model, vm.key);\t\t// vm.opts\n\n\t// always assign vm key to root vnode (this is a de-opt)\n\tif (vm.key !== false && vm.key != null && vnew.key !== vm.key)\n\t\tvnew.key = vm.key;\n\n//\tconsole.log(vm.key);\n\n\tvm.node = vnew;\n\n\tif (newParent) {\n\t\tpreProc(vnew, newParent, newIdx, vm);\n\t\tnewParent.body[newIdx] = vnew;\n\t\t// todo: bubble refs, etc?\n\t}\n\telse if (vold && vold.parent) {\n\t\tpreProc(vnew, vold.parent, vold.idx, vm);\n\t\tvold.parent.body[vold.idx] = vnew;\n\t}\n\telse\n\t\tpreProc(vnew, null, null, vm);\n\n\tif (withDOM !== false) {\n\t\tif (vold) {\n\t\t\t// root node replacement\n\t\t\tif (vold.tag !== vnew.tag) {\n\t\t\t\t// hack to prevent the replacement from triggering mount/unmount\n\t\t\t\tvold.vm = vnew.vm = null;\n\n\t\t\t\tvar parEl = vold.el.parentNode;\n\t\t\t\tvar refEl = nextSib(vold.el);\n\t\t\t\tremoveChild(parEl, vold.el);\n\t\t\t\tinsertBefore(parEl, hydrate(vnew), refEl);\n\n\t\t\t\t// another hack that allows any higher-level syncChildren to set\n\t\t\t\t// reconciliation bounds using a live node\n\t\t\t\tvold.el = vnew.el;\n\n\t\t\t\t// restore\n\t\t\t\tvnew.vm = vm;\n\t\t\t}\n\t\t\telse\n\t\t\t\tpatch(vnew, vold, isRedrawRoot);\n\t\t}\n\t\telse\n\t\t\thydrate(vnew);\n\t}\n\n\tisMounted && vm.hooks && fireHooks(\"didRedraw\", vm);\n\n\tif (isRedrawRoot && isMounted)\n\t\tdrainDidHooks(vm);\n\n\treturn vm;\n}\n\n// withRedraw?\n// this doubles as moveTo\n// will/didUpdate\nfunction updateSync(newModel, newParent, newIdx, withDOM) {\t\t\t// parentVm\n\tvar vm = this;\n\n\tif (newModel != null) {\t\t// && vm.key !== vm.model\n\t\tif (vm.model !== newModel) {\n\t\t\tif (_DEVMODE) {\n\t\t\t\tdevNotify(\"MODEL_REPLACED\", [vm, vm.model, newModel]);\n\t\t\t}\n\t\t\tvm.hooks && fireHooks(\"willUpdate\", vm, newModel);\t\t// willUpdate will be called ahead of willRedraw when model will be replaced\n\t\t\tvm.model = newModel;\n\t\t//\tvm.hooks && fireHooks(\"didUpdate\", vm, newModel);\t\t// should this fire at al?\n\t\t}\n\t}\n\n\t// TODO: prevent redraw from firing?\n\n\treturn vm._redraw(newParent, newIdx, withDOM);\n/*\n\tif (parentVm != null) {\n\t\tvm.parent = parentVm;\n\t\tparentVm.body.push(vm);\n\t}\n*/\n}","import { isPlainObj } from '../utils';\nimport { initElementNode } from './initElementNode';\n\nexport function defineElement(tag, arg1, arg2, flags) {\n\tvar attrs, body;\n\n\tif (arg2 == null) {\n\t\tif (isPlainObj(arg1))\n\t\t\tattrs = arg1;\n\t\telse\n\t\t\tbody = arg1;\n\t}\n\telse {\n\t\tattrs = arg1;\n\t\tbody = arg2;\n\t}\n\n\treturn initElementNode(tag, attrs, body, flags);\n}","import { defineElement } from \"./defineElement\";\n\n//export const XML_NS = \"http://www.w3.org/2000/xmlns/\";\nexport const SVG_NS = \"http://www.w3.org/2000/svg\";\n//export const XLINK_NS = \"http://www.w3.org/1999/xlink\";\n\nexport function defineSvgElement(tag, arg1, arg2, flags) {\n\tvar n = defineElement(tag, arg1, arg2, flags);\n\tn.ns = SVG_NS;\n\treturn n;\n}","import { COMMENT } from './VTYPES';\nimport { VNode } from './VNode';\n\nexport function defineComment(body) {\n\tlet node = new VNode;\n\tnode.type = COMMENT;\n\tnode.body = body;\n\treturn node;\n}","import { VVIEW } from './VTYPES';\n\n// placeholder for declared views\nexport function VView(view, model, key, opts) {\n\tthis.view = view;\n\tthis.model = model;\n\tthis.key = key == null ? model : key;\t// same logic as ViewModel\n\tthis.opts = opts;\n}\n\nVView.prototype = {\n\tconstructor: VView,\n\n\ttype: VVIEW,\n\tview: null,\n\tmodel: null,\n\tkey: null,\n\topts: null,\n};","import { VView } from './VView';\n\nexport function defineView(view, model, key, opts) {\n\treturn new VView(view, model, key, opts);\n}","import { VMODEL } from './VTYPES';\n\n// placeholder for injected ViewModels\nexport function VModel(vm) {\n\tthis.vm = vm;\n}\n\nVModel.prototype = {\n\tconstructor: VModel,\n\n\ttype: VMODEL,\n\tvm: null,\n};","import { VModel } from './VModel';\n\n\nexport function injectView(vm) {\n//\tif (vm.node == null)\n//\t\tvm._redraw(null, null, false);\n\n//\treturn vm.node;\n\n\treturn new VModel(vm);\n}","import { ELEMENT } from './VTYPES';\nimport { VNode } from './VNode';\n\nexport function injectElement(el) {\n\tlet node = new VNode;\n\tnode.type = ELEMENT;\n\tnode.el = node.key = el;\n\treturn node;\n}","// NOTE: if adding a new *VNode* type, make it < COMMENT and renumber rest.\n// There are some places that test <= COMMENT to assert if node is a VNode\n\n// VNode types\nexport const ELEMENT\t= 1;\nexport const TEXT\t\t= 2;\nexport const COMMENT\t= 3;\n\n// placeholder types\nexport const VVIEW\t\t= 4;\nexport const VMODEL\t\t= 5;","import { ViewModel } from \"../view/ViewModel\";\nimport { VNode } from \"../view/VNode\";\n\nimport { createView } from \"../view/createView\";\n\nimport { defineElement } from \"../view/defineElement\";\nimport { defineSvgElement } from \"../view/defineSvgElement\";\nimport { defineText } from \"../view/defineText\";\nimport { defineComment } from \"../view/defineComment\";\nimport { defineView } from \"../view/defineView\";\n\nimport { injectView } from \"../view/injectView\";\nimport { injectElement } from \"../view/injectElement\";\n\nimport { FIXED_BODY, DEEP_REMOVE, KEYED_LIST } from \"../view/initElementNode\";\n\nimport { config } from '../view/config';\n\nexport default {\n\tconfig,\n\n\tViewModel,\n\tVNode,\n\n\tcreateView,\n\n\tdefineElement,\n\tdefineSvgElement,\n\tdefineText,\n\tdefineComment,\n\tdefineView,\n\n\tinjectView,\n\tinjectElement,\n\n\tFIXED_BODY,\n\tDEEP_REMOVE,\n\tKEYED_LIST,\n}"],"names":["noop","isSet","val","isPlainObj","constructor","Object","insertArr","targ","arr","pos","rem","splice","apply","concat","isVal","t","isFunc","isProm","then","assignObj","args","arguments","i","length","k","deepSet","path","seg","shift","cmpArr","a","b","const","alen","raft","fn","call","id","ctx","rAF","this","curry","binaryKeySearch","list","item","guess","min","max","key","Math","floor","isEvProp","name","isSplProp","isStyleProp","repaint","node","el","offsetHeight","isDynProp","tag","attr","getVm","n","emptyObj","vm","parent","isStreamStub","autoPxStub","cssTagStub","tagObj","patchStyle","o","ns","attrs","style","os","cssText","nn","nv","isStream","hookStream","autoPx","on","fireHook","did","immediate","didQueue","push","fireHooks","hook","hooks","isArr","map","hook2","VNode","initElementNode","body","flags","let","type","ELEMENT","parsed","cssTag","class","p","_class","mergedAttrs","_key","_ref","ref","_hooks","_raw","raw","_data","data","_flags","closestVNode","_node","parentNode","createElement","doc","createElementNS","createTextNode","createComment","nextSib","sib","nextSibling","prevSib","previousSibling","deepNotifyRemove","res","DEEP_REMOVE","_removeChild","parEl","removeChild","clearChildren","textContent","firstChild","insertBefore","refEl","inDom","insertAfter","config","newCfg","globalCfg","bindEv","handle","e","target","out","onevent","preventDefault","stopPropagation","wrapHandler","wrapHandlers","hash","sel","matches","hnd","isarr","slice","patchEvent","nval","oval","remAttr","asProp","removeAttribute","setAttr","setAttribute","className","substr","patchAttrs","vnode","donor","nattrs","oattrs","isDyn","createView","view","model","opts","VVIEW","prototype","_isClass","ViewModel","patchAttrs2","hydrateBody","vnode2","type2","COMMENT","hydrate","_redraw","VMODEL","withEl","innerHTML","TEXT","nextNode","idx","prevNode","tmpEdges","lftSib","rgtSib","lftLft","rgtRgt","lastChild","headTailTry","lftNode","rgtNode","areAdjacent","headToTail","tailToHead","sortDOM","cmpFn","j","cmpElNodeIdx","syncChildren","newSibs","tmpSib","lsNode","rsNode","obody","converge","unmount","findDonor","fromIdx","toIdx","ov","findListDonor","patch","isRedrawRoot","nbody","oldIsArr","newIsArr","patchChildren","nodeValue","sortByKey","nlen","domSync","FIXED_BODY","isList","KEYED_LIST","sort","find","donor2","node2","_update","defineText","setRef","split","setDeepRemove","preProc","vnew","ownVm","willRemove","willUnmount","preProcBody","vdiff","diff","ViewModelProto","bind","render","_redrawAsync","_","_updateAsync","newModel","didInit","drainDidHooks","mount","isRoot","nodeName","toLowerCase","asSub","redrawSync","newParent","newIdx","withDOM","isMounted","vold","_diff","refs","updateSync","defineElement","arg1","arg2","defineSvgElement","SVG_NS","defineComment","VView","defineView","VModel","injectView","injectElement","ENV_DOM","window","requestAnimationFrame","Array","isArray","hookStreamStub","document","root","api","redraw","sync","update"],"mappings":"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"}